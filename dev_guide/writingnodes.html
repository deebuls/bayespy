<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementing nodes &mdash; BayesPy v0.4.1 Documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.4.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BayesPy v0.4.1 Documentation" href="../index.html" />
    <link rel="up" title="Developer guide" href="dev_guide.html" />
    <link rel="next" title="User API" href="../user_api/user_api.html" />
    <link rel="prev" title="Implementing inference engines" href="engine.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../user_api/user_api.html" title="User API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="engine.html" title="Implementing inference engines"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">BayesPy v0.4.1 Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="dev_guide.html" accesskey="U">Developer guide</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementing nodes</a><ul>
<li><a class="reference internal" href="#moments">Moments</a></li>
<li><a class="reference internal" href="#distributions">Distributions</a></li>
<li><a class="reference internal" href="#stochastic-exponential-family-nodes">Stochastic exponential family nodes</a></li>
<li><a class="reference internal" href="#deterministic-nodes">Deterministic nodes</a><ul>
<li><a class="reference internal" href="#converter-nodes">Converter nodes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="engine.html"
                        title="previous chapter">Implementing inference engines</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../user_api/user_api.html"
                        title="next chapter">User API</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/dev_guide/writingnodes.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="implementing-nodes">
<h1>Implementing nodes<a class="headerlink" href="#implementing-nodes" title="Permalink to this headline">¶</a></h1>
<p>The main goal of BayesPy is to provide a package which enables easy and flexible
construction of simple and complex models with efficient inference.  However,
users may sometimes be unable to construct their models because the built-in
nodes do not implement some specific features.  Thus, one may need to implement
new nodes in order to construct the model.  BayesPy aims to make the
implementation of new nodes both simple and fast.  Probably, a large complex
model can be constructed almost completely with the built-in nodes and the user
needs to implement only a few nodes.</p>
<div class="section" id="moments">
<h2>Moments<a class="headerlink" href="#moments" title="Permalink to this headline">¶</a></h2>
<p>In order to implement nodes, it is important to understand the messaging
framework of the nodes.  A node is a unit of calculation which communicates to
its parent and child nodes using messages.  These messages have types that need
to match between nodes, that is, the child node needs to understand the messages
its parents are sending and vice versa.  Thus, a node defines which message type
it requires from each of its parents, and only nodes that have that type of
output message (i.e., the message to a child node) are valid parent nodes for
that node.</p>
<p>The message type is defined by the moments of the parent node.  The moments are
a collection of expectations: <span class="math">\(\{ \langle f_1(X) \rangle, \ldots, \langle
f_N(X) \rangle \}\)</span>.  The functions <span class="math">\(f_1, \ldots, f_N\)</span> (and the number of
the functions) define the message type and they are the sufficient statistic as
discussed in the previous section.  Different message types are represented by
<a class="reference internal" href="../dev_api/generated/bayespy.inference.vmp.nodes.node.Moments.html#bayespy.inference.vmp.nodes.node.Moments" title="bayespy.inference.vmp.nodes.node.Moments"><code class="xref py py-class docutils literal"><span class="pre">Moments</span></code></a> class hierarchy.  For instance, <code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code>
represents a message type with parent moments <span class="math">\(\{\langle \mathbf{x}
\rangle, \langle \mathbf{xx}^T \rangle \}\)</span> and <code class="xref py py-class docutils literal"><span class="pre">WishartMoments</span></code> a message
type with parent moments <span class="math">\(\{\langle \mathbf{\Lambda} \rangle, \langle \log
|\mathbf{\Lambda}| \rangle\}\)</span>.</p>
<p>Let us give an example: <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Gaussian.html#bayespy.nodes.Gaussian" title="bayespy.nodes.Gaussian"><code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code></a> node outputs <code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code>
messages and <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Wishart.html#bayespy.nodes.Wishart" title="bayespy.nodes.Wishart"><code class="xref py py-class docutils literal"><span class="pre">Wishart</span></code></a> node outputs <code class="xref py py-class docutils literal"><span class="pre">WishartMoments</span></code> messages.
<a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Gaussian.html#bayespy.nodes.Gaussian" title="bayespy.nodes.Gaussian"><code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code></a> node requires that it receives <code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code>
messages from the mean parent node and <code class="xref py py-class docutils literal"><span class="pre">WishartMoments</span></code> messages from the
precision parent node.  Thus, <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Gaussian.html#bayespy.nodes.Gaussian" title="bayespy.nodes.Gaussian"><code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code></a> and <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Wishart.html#bayespy.nodes.Wishart" title="bayespy.nodes.Wishart"><code class="xref py py-class docutils literal"><span class="pre">Wishart</span></code></a> are valid
node classes as the mean and precision parent nodes of <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Gaussian.html#bayespy.nodes.Gaussian" title="bayespy.nodes.Gaussian"><code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code></a> node.</p>
<p>Note that several nodes may have the same output message type and some message
types can be transformed to other message types using deterministic converter
nodes.  For instance, <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.Gaussian.html#bayespy.nodes.Gaussian" title="bayespy.nodes.Gaussian"><code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code></a> and <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.GaussianARD.html#bayespy.nodes.GaussianARD" title="bayespy.nodes.GaussianARD"><code class="xref py py-class docutils literal"><span class="pre">GaussianARD</span></code></a> nodes both
output <code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code> messages, deterministic <a class="reference internal" href="../user_api/generated/generated/bayespy.nodes.SumMultiply.html#bayespy.nodes.SumMultiply" title="bayespy.nodes.SumMultiply"><code class="xref py py-class docutils literal"><span class="pre">SumMultiply</span></code></a>
also outputs <code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code> messages, and deterministic converter
<code class="xref py py-class docutils literal"><span class="pre">_MarkovChainToGaussian</span></code> converts <code class="xref py py-class docutils literal"><span class="pre">GaussianMarkovChainMoments</span></code> to
<code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code>.</p>
<p>Each node specifies the message type requirements of its parents by
<code class="xref py py-attr docutils literal"><span class="pre">Node._parent_moments</span></code> attribute which is a list of <a class="reference internal" href="../dev_api/generated/bayespy.inference.vmp.nodes.node.Moments.html#bayespy.inference.vmp.nodes.node.Moments" title="bayespy.inference.vmp.nodes.node.Moments"><code class="xref py py-class docutils literal"><span class="pre">Moments</span></code></a>
sub-class instances.  These moments objects have a few purpose when creating the
node: 1) check that parents are sending proper messages; 2) if parents use
different message type, try to add a converter which converts the messages to
the correct type if possible; 3) if given parents are not nodes but numeric
arrays, convert them to constant nodes with correct output message type.</p>
<p>When implementing a new node, it is not always necessary to implement a new
moments class.  If another node has the same sufficient statistic vector, thus
the same moments, that moments class can be used.  Otherwise, one must implement
a simple moments class which has the following methods:</p>
<blockquote>
<div><ul>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.node.Moments.compute_fixed_moments.html#bayespy.inference.vmp.nodes.node.Moments.compute_fixed_moments" title="bayespy.inference.vmp.nodes.node.Moments.compute_fixed_moments"><code class="xref py py-func docutils literal"><span class="pre">Moments.compute_fixed_moments()</span></code></a></p>
<blockquote>
<div><p>Computes the moments for a known value.  This is used to compute the
moments of constant numeric arrays and wrap them into constant nodes.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.node.Moments.compute_dims_from_values.html#bayespy.inference.vmp.nodes.node.Moments.compute_dims_from_values" title="bayespy.inference.vmp.nodes.node.Moments.compute_dims_from_values"><code class="xref py py-func docutils literal"><span class="pre">Moments.compute_dims_from_values()</span></code></a></p>
<blockquote>
<div><p>Given a known value of the variable, return the shape of the variable
dimensions in the moments.  This is used to solve the shape of the moments
array for constant nodes.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="distributions">
<h2>Distributions<a class="headerlink" href="#distributions" title="Permalink to this headline">¶</a></h2>
<p>In order to implement a stochastic exponential family node, one must first write
down the log probability density function of the node and derive the terms
discussed in section <a class="reference internal" href="vmp.html#sec-vmp-terms"><span>Terms</span></a>.  These terms are implemented and
collected as a class which is a subclass of <code class="xref py py-class docutils literal"><span class="pre">Distribution</span></code>.  The main
reason to implement these methods in another class instead of the node class
itself is that these methods can be used without creating a node, for instance,
in <code class="xref py py-class docutils literal"><span class="pre">Mixture</span></code> class.</p>
<p>For exponential family distributions, the distribution class is a subclass of
<a class="reference internal" href="../dev_api/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution"><code class="xref py py-class docutils literal"><span class="pre">ExponentialFamilyDistribution</span></code></a>, and the relation between the terms in
section <a class="reference internal" href="vmp.html#sec-vmp-terms"><span>Terms</span></a> and the methods is as follows:</p>
<blockquote>
<div><ul>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_phi_from_parents.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_phi_from_parents" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_phi_from_parents"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.compute_phi_from_parents()</span></code></a></p>
<blockquote>
<div><p>Computes the expectation of the natural parameters <span class="math">\(\langle
\boldsymbol{\phi} \rangle\)</span> in the prior distribution given the moments of
the parents.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_cgf_from_parents.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_cgf_from_parents" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_cgf_from_parents"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.compute_cgf_from_parents()</span></code></a></p>
<blockquote>
<div><p>Computes the expectation of the negative log normalizer <span class="math">\(\langle g
\rangle\)</span> of the prior distribution given the moments of the parents.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_moments_and_cgf.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_moments_and_cgf" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_moments_and_cgf"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.compute_moments_and_cgf()</span></code></a></p>
<blockquote>
<div><p>Computes the moments <span class="math">\(\langle \mathbf{u} \rangle\)</span> and the negative
log normalizer <span class="math">\(\tilde{g}\)</span> of the posterior distribution
given the natural parameters <span class="math">\(\tilde{\boldsymbol{\phi}}\)</span>.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_message_to_parent.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_message_to_parent" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_message_to_parent"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.compute_message_to_parent()</span></code></a></p>
<blockquote>
<div><p>Computes the message <span class="math">\(\langle
\boldsymbol{\phi}_{\mathbf{x}\rightarrow\boldsymbol{\theta}} \rangle\)</span> from
the node <span class="math">\(\mathbf{x}\)</span> to its parent node <span class="math">\(\boldsymbol{\theta}\)</span>
given the moments of the node and the other parents.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_fixed_moments_and_f.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_fixed_moments_and_f" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_fixed_moments_and_f"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.compute_fixed_moments_and_f()</span></code></a></p>
<blockquote>
<div><p>Computes <span class="math">\(\mathbf{u}(\mathbf{x})\)</span> and <span class="math">\(f(\mathbf{x})\)</span> for
given observed value <span class="math">\(\mathbf{x}\)</span>.  Without this method, variables
from this distribution cannot be observed.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>For each stochastic exponential family node, one must write a distribution class
which implements these methods.  After that, the node class is basically a
simple wrapper and it also stores the moments and the natural parameters of the
current posterior approximation.  Note that the distribution classes do not
store node-specific information, they are more like static collections of
methods.  However, sometimes the implementations depend on some information,
such as the dimensionality of the variable, and this information must be
provided, if needed, when constructing the distribution object.</p>
<p>In addition to the methods listed above, it is necessary to implement a few more
methods in some cases.  This happens when the plates of the parent do not map to
the plates directly as discussed in section <a class="reference internal" href="../user_guide/modelconstruct.html#sec-irregular-plates"><span>Irregular plates</span></a>.  Then,
one must write methods that implement this plate mapping and apply the same
mapping to the mask array:</p>
<blockquote>
<div><ul>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.plates_from_parent.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.plates_from_parent" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.plates_from_parent"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.plates_from_parent()</span></code></a></p>
<blockquote>
<div><p>Given the plates of the parent, return the resulting plates of the child.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.plates_to_parent.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.plates_to_parent" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.plates_to_parent"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.plates_to_parent()</span></code></a></p>
<blockquote>
<div><p>Given the plates of the child, return the plates of the parent that would
have resulted them.</p>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_mask_to_parent.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_mask_to_parent" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_mask_to_parent"><code class="xref py py-func docutils literal"><span class="pre">ExponentialFamilyDistribution.compute_mask_to_parent()</span></code></a></p>
<blockquote>
<div><p>Given the mask array of the child, apply the plate mapping.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>It is important to understand when one must implement these methods, because the
default implementations in the base class will lead to errors or weird results.</p>
</div>
<div class="section" id="stochastic-exponential-family-nodes">
<h2>Stochastic exponential family nodes<a class="headerlink" href="#stochastic-exponential-family-nodes" title="Permalink to this headline">¶</a></h2>
<p>After implementing the distribution class, the next task is to implement the
node class.  First, we need to explain a few important attributes before we can
explain how to implement a node class.</p>
<p>Stochastic exponential family nodes have two attributes that store the state of
the posterior distribution:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">phi</span></code></p>
<p>The natural parameter vector <span class="math">\(\tilde{\boldsymbol{\phi}}\)</span> of the
posterior approximation.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">u</span></code></p>
<p>The moments <span class="math">\(\langle \mathbf{u} \rangle\)</span> of the posterior
approximation.</p>
</li>
</ul>
</div></blockquote>
<p>Instead of storing these two variables as vectors (as in the mathematical
formulas), they are stored as lists of arrays with convenient shapes.  For
instance, <code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code> node stores the moments as a list consisting of a
vector <span class="math">\(\langle \mathbf{x} \rangle\)</span> and a matrix <span class="math">\(\langle
\mathbf{xx}^T \rangle\)</span> instead of reshaping and concatenating these into a
single vector.  The same applies for the natural parameters <code class="docutils literal"><span class="pre">phi</span></code> because it
has the same shape as <code class="docutils literal"><span class="pre">u</span></code>.</p>
<p>The shapes of the arrays in the lists <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">phi</span></code> consist of the shape
caused by the plates and the shape caused by the variable itself.  For instance,
the moments of <code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code> node have shape <code class="docutils literal"><span class="pre">(D,)</span></code> and <code class="docutils literal"><span class="pre">(D,</span> <span class="pre">D)</span></code>, where
<code class="docutils literal"><span class="pre">D</span></code> is the dimensionality of the Gaussian vector.  In addition, if the node
has plates, they are added to these shapes.  Thus, for instance, if the
<code class="xref py py-class docutils literal"><span class="pre">Gaussian</span></code> node has plates <code class="docutils literal"><span class="pre">(3,</span> <span class="pre">7)</span></code> and <code class="docutils literal"><span class="pre">D</span></code> is 5, the shape of
<code class="docutils literal"><span class="pre">u[0]</span></code> and <code class="docutils literal"><span class="pre">phi[0]</span></code> would be <code class="docutils literal"><span class="pre">(3,</span> <span class="pre">7,</span> <span class="pre">5)</span></code> and the shape of <code class="docutils literal"><span class="pre">u[1]</span></code> and
<code class="docutils literal"><span class="pre">phi[1]</span></code> would be <code class="docutils literal"><span class="pre">(3,</span> <span class="pre">7,</span> <span class="pre">5,</span> <span class="pre">5)</span></code>.  This shape information is stored in the
following attributes:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">plates</span></code> : a tuple</p>
<p>The plates of the node.  In our example, <code class="docutils literal"><span class="pre">(3,</span> <span class="pre">7)</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">dims</span></code> : a list of tuples</p>
<p>The shape of each of the moments arrays (or natural parameter arrays) without
plates.  In our example, <code class="docutils literal"><span class="pre">[</span> <span class="pre">(5,),</span> <span class="pre">(5,</span> <span class="pre">5)</span> <span class="pre">]</span></code>.</p>
</li>
</ul>
</div></blockquote>
<p>Finally, three attributes define VMP for the node:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">_moments</span></code> : <code class="xref py py-class docutils literal"><span class="pre">Moments</span></code> sub-class instance</p>
<p>An object defining the moments of the node.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">_parent_moments</span></code> : list of <code class="xref py py-class docutils literal"><span class="pre">Moments</span></code> sub-class instances</p>
<p>A list defining the moments requirements for each parent.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">_distribution</span></code> : <code class="xref py py-class docutils literal"><span class="pre">Distribution</span></code> sub-class instance</p>
<p>An object implementing the VMP formulas.</p>
</li>
</ul>
</div></blockquote>
<p>Basically, a node class is a collection of the above attributes.  When a node is
created, these attributes are defined.  The base class for exponential family
nodes, <a class="reference internal" href="../dev_api/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily" title="bayespy.inference.vmp.nodes.expfamily.ExponentialFamily"><code class="xref py py-class docutils literal"><span class="pre">ExponentialFamily</span></code></a>, provides a simple default constructor which
does not need to be overwritten if <code class="docutils literal"><span class="pre">dims</span></code>, <code class="docutils literal"><span class="pre">_moments</span></code>, <code class="docutils literal"><span class="pre">_parent_moments</span></code>
and <code class="docutils literal"><span class="pre">_distribution</span></code> can be provided as static class attributes.  For instance,
<code class="xref py py-class docutils literal"><span class="pre">Gamma</span></code> node defines these attributes statically.  However, usually at
least one of these attributes cannot be defined statically in the class.  In
that case, one must implement a class method which overloads
<code class="xref py py-func docutils literal"><span class="pre">ExponentialFamily._constructor()</span></code>.  The purpose of this method is to define
all the attributes given the parent nodes.  These are defined using a class
method instead of <code class="docutils literal"><span class="pre">__init__</span></code> method in order to be able to use the class
constructors statically, for instance, in <code class="xref py py-class docutils literal"><span class="pre">Mixture</span></code> class.  This
construction allows users to create mixtures of any exponential family
distribution with simple syntax.</p>
<p>The parents of a node must be converted so that they have a correct message
type, because the user may have provided numeric arrays or nodes with incorrect
message type.  Numeric arrays should be converted to constant nodes with correct
message type.  Incorrect message type nodes should be converted to correct
message type nodes if possible.  Thus, the constructor should use
<code class="docutils literal"><span class="pre">Node._ensure_moments</span></code> method to make sure the parent is a node with correct
message type.  Instead of calling this method for each parent node in the
constructor, one can use <code class="docutils literal"><span class="pre">ensureparents</span></code> decorator to do this automatically.
However, the decorator requires that <code class="docutils literal"><span class="pre">_parent_moments</span></code> attribute has already
been defined statically.  If this is not possible, the parent nodes must be
converted manually in the constructor, because one should never assume that the
parent nodes given to the constructor are nodes with correct message type or
even nodes at all.</p>
</div>
<div class="section" id="deterministic-nodes">
<h2>Deterministic nodes<a class="headerlink" href="#deterministic-nodes" title="Permalink to this headline">¶</a></h2>
<p>Deterministic nodes are nodes that do not correspond to any probability
distribution but rather a deterministic function.  It does not have any moments
or natural parameters to store.  A deterministic node is implemented as a
subclass of <code class="xref py py-class docutils literal"><span class="pre">Deterministic</span></code> base class.  The new node class must
implement the following methods:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">Deterministic._compute_moments()</span></code></p>
<p>Computes the moments given the moments of the parents.</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">Deterministic._compute_message_to_parent()</span></code></p>
<p>Computes the message to a parent node given the message from the children and
the moments of the other parents.  In some cases, one may want to implement
<code class="xref py py-func docutils literal"><span class="pre">Deterministic._compute_message_and_mask_to_parent()</span></code> or
<code class="xref py py-func docutils literal"><span class="pre">Deterministic._message_to_parent()</span></code> instead in order to gain more
control over efficient computation.</p>
</li>
</ul>
</div></blockquote>
<p>Similarly as in <code class="xref py py-class docutils literal"><span class="pre">Distribution</span></code> class, if the node handles plates
irregularly, it is important to implement the following methods:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">Deterministic._plates_from_parent()</span></code></p>
<p>Given the plates of the parent, return the resulting plates of the child.</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">Deterministic._plates_to_parent()</span></code></p>
<p>Given the plates of the child, return the plates of the parent that would
have resulted them.</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">Deterministic._compute_mask_to_parent()</span></code></p>
<p>Given the mask array, convert it to a plate mask of the parent.</p>
</li>
</ul>
</div></blockquote>
<div class="section" id="converter-nodes">
<h3>Converter nodes<a class="headerlink" href="#converter-nodes" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a node has incorrect message type but the message can be converted
into a correct type.  For instance, <code class="xref py py-class docutils literal"><span class="pre">GaussianMarkovChain</span></code> has
<code class="xref py py-class docutils literal"><span class="pre">GaussianMarkovChainMoments</span></code> message type, which means moments <span class="math">\(\{
\langle \mathbf{x}_n \rangle, \langle \mathbf{x}_n \mathbf{x}_n^T \rangle,
\langle \mathbf{x}_n \mathbf{x}_{n-1}^T \rangle \}^N_{n=1}\)</span>.  These moments can
be converted to <code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code> by ignoring the third element and
considering the time axis as a plate axis.  Thus, if a node requires
<code class="xref py py-class docutils literal"><span class="pre">GaussianMoments</span></code> message from its parent, <code class="xref py py-class docutils literal"><span class="pre">GaussianMarkovChain</span></code>
is a valid parent if its messages are modified properly.  This conversion is
implemented in <code class="xref py py-class docutils literal"><span class="pre">_MarkovChainToGaussian</span></code> converter class.  Converter nodes
are simple deterministic nodes that have one parent node and they convert the
messages to another message type.</p>
<p>For the user, it is not convenient if the exact message type has to be known and
an explicit converter node needs to be created.  Thus, the conversions are done
automatically and the user will be unaware of them.  In order to enable this
automatization, when writing a converter node, one should register the converter
to the moments class using <code class="xref py py-func docutils literal"><span class="pre">Moments.add_converter()</span></code>.  For instance, a class
<code class="docutils literal"><span class="pre">X</span></code> which converts moments <code class="docutils literal"><span class="pre">A</span></code> to moments <code class="docutils literal"><span class="pre">B</span></code> is registered as
<code class="docutils literal"><span class="pre">A.add_conveter(B,</span> <span class="pre">X)</span></code>.  After that, <code class="xref py py-func docutils literal"><span class="pre">Node._ensure_moments()</span></code> and
<code class="xref py py-func docutils literal"><span class="pre">Node._convert()</span></code> methods are used to perform the conversions automatically.
The conversion can consist of several consecutive converter nodes, and the least
number of conversions is used.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../user_api/user_api.html" title="User API"
             >next</a> |</li>
        <li class="right" >
          <a href="engine.html" title="Implementing inference engines"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">BayesPy v0.4.1 Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="dev_guide.html" >Developer guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-2015, Jaakko Luttinen, MIT.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>