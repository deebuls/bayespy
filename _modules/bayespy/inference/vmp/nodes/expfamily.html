<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bayespy.inference.vmp.nodes.expfamily &mdash; BayesPy v0.4.0 Documentation</title>
    
    <link rel="stylesheet" href="../../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '0.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BayesPy v0.4.0 Documentation" href="../../../../../index.html" />
    <link rel="up" title="Module code" href="../../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">BayesPy v0.4.0 Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for bayespy.inference.vmp.nodes.expfamily</h1><div class="highlight"><pre>
<span class="c">################################################################################</span>
<span class="c"># Copyright (C) 2013-2014 Jaakko Luttinen</span>
<span class="c">#</span>
<span class="c"># This file is licensed under the MIT License.</span>
<span class="c">################################################################################</span>


<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">bayespy.utils</span> <span class="kn">import</span> <span class="n">misc</span>

<span class="kn">from</span> <span class="nn">.node</span> <span class="kn">import</span> <span class="n">ensureparents</span>
<span class="kn">from</span> <span class="nn">.stochastic</span> <span class="kn">import</span> <span class="n">Stochastic</span><span class="p">,</span> <span class="n">Distribution</span>

<div class="viewcode-block" id="ExponentialFamilyDistribution"><a class="viewcode-back" href="../../../../../dev_api/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution">[docs]</a><span class="k">class</span> <span class="nc">ExponentialFamilyDistribution</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sub-classes implement distribution specific computations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#</span>
    <span class="c"># The following methods are for ExponentialFamily distributions</span>
    <span class="c">#</span>

<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_message_to_parent"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_message_to_parent.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_message_to_parent">[docs]</a>    <span class="k">def</span> <span class="nf">compute_message_to_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">u_self</span><span class="p">,</span> <span class="o">*</span><span class="n">u_parents</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_phi_from_parents"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_phi_from_parents.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_phi_from_parents">[docs]</a>    <span class="k">def</span> <span class="nf">compute_phi_from_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">u_parents</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_moments_and_cgf"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_moments_and_cgf.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_moments_and_cgf">[docs]</a>    <span class="k">def</span> <span class="nf">compute_moments_and_cgf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c">#</span>
    <span class="c"># The following methods are for Mixture class</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_cgf_from_parents"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_cgf_from_parents.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_cgf_from_parents">[docs]</a>    <span class="k">def</span> <span class="nf">compute_cgf_from_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">u_parents</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_fixed_moments_and_f"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_fixed_moments_and_f.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_fixed_moments_and_f">[docs]</a>    <span class="k">def</span> <span class="nf">compute_fixed_moments_and_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_logpdf"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_logpdf.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_logpdf">[docs]</a>    <span class="k">def</span> <span class="nf">compute_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ndims</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute E[log p(X)] given E[u], E[phi], E[g] and</span>
<span class="sd">        E[f]. Does not sum over plates.&quot;&quot;&quot;</span>

        <span class="c"># TODO/FIXME: Should I take into account what is latent or</span>
        <span class="c"># observed, or what is even totally ignored (by the mask).</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">f</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">phi_i</span><span class="p">,</span> <span class="n">u_i</span><span class="p">,</span> <span class="n">ndims_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ndims</span><span class="p">):</span>
            <span class="c"># Axes to sum (dimensions of the variable, not the plates)</span>
            <span class="n">axis_sum</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">ndims_i</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="c"># Compute the term</span>
            <span class="c"># TODO/FIXME: Use einsum!</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">phi_i</span> <span class="o">*</span> <span class="n">u_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_sum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span>

</div>
<div class="viewcode-block" id="ExponentialFamilyDistribution.compute_gradient"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_gradient.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamilyDistribution.compute_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">compute_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Compute the standard gradient with respect to the natural parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Standard gradient not yet implemented for </span><span class="si">%s</span><span class="s">&quot;</span>
                                  <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>


</div></div>
<span class="k">def</span> <span class="nf">useconstructor</span><span class="p">(</span><span class="n">__init__</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">constructor_decorator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_moments</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_moments</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>

            <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">plates</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">pstats</span><span class="p">)</span> <span class="o">=</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_moments</span> <span class="o">=</span> <span class="n">stats</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_moments</span> <span class="o">=</span> <span class="n">pstats</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plates</span> <span class="o">=</span> <span class="n">plates</span>

        <span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">constructor_decorator</span>

<div class="viewcode-block" id="ExponentialFamily"><a class="viewcode-back" href="../../../../../dev_api/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily">[docs]</a><span class="k">class</span> <span class="nc">ExponentialFamily</span><span class="p">(</span><span class="n">Stochastic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class for nodes using natural parameterization `phi`.</span>

<span class="sd">    phi</span>

<span class="sd">    Sub-classes must implement the following static methods:</span>
<span class="sd">       _compute_message_to_parent(index, u_self, *u_parents)</span>
<span class="sd">       _compute_phi_from_parents(*u_parents, mask)</span>
<span class="sd">       _compute_moments_and_cgf(phi, mask)</span>
<span class="sd">       _compute_fixed_moments_and_f(x, mask=True)</span>

<span class="sd">    Sub-classes may need to re-implement:</span>
<span class="sd">    1. If they manipulate plates:</span>
<span class="sd">       _compute_mask_to_parent(index, mask)</span>
<span class="sd">       _compute_plates_to_parent(self, index, plates)</span>
<span class="sd">       _compute_plates_from_parent(self, index, plates)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Sub-classes should overwrite this (possibly using _constructor)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="c"># Sub-classes should overwrite this</span>
    <span class="n">_distribution</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@useconstructor</span>
<div class="viewcode-block" id="ExponentialFamily.__init__"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.__init__.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parents</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">annealing</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c"># Terms for the lower bound (G for latent and F for observed)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">parents</span><span class="p">,</span>
                         <span class="n">initialize</span><span class="o">=</span><span class="n">initialize</span><span class="p">,</span>
                         <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">initialize</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">misc</span><span class="o">.</span><span class="n">nans</span><span class="p">(</span><span class="n">axes</span><span class="o">+</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">]</span>

</div>
    <span class="nd">@classmethod</span>
    <span class="nd">@ensureparents</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">parents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs distribution and moments objects.</span>

<span class="sd">        If __init__ uses useconstructor decorator, this method is called to</span>
<span class="sd">        construct distribution and moments objects.</span>

<span class="sd">        The method is given the same inputs as __init__. For some nodes, some of</span>
<span class="sd">        these can&#39;t be &quot;static&quot; class attributes, then the node class must</span>
<span class="sd">        overwrite this method to construct the objects manually.</span>

<span class="sd">        The point of distribution class is to move general distribution but</span>
<span class="sd">        not-node specific code. The point of moments class is to define the</span>
<span class="sd">        messaging protocols.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_plates</span> <span class="o">=</span> <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">plates_from_parent</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>
                         <span class="k">for</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parents</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">parents</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="p">,</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">_total_plates</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;plates&#39;</span><span class="p">),</span> <span class="o">*</span><span class="n">parent_plates</span><span class="p">),</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">_distribution</span><span class="p">,</span> 
                <span class="n">cls</span><span class="o">.</span><span class="n">_moments</span><span class="p">,</span> 
                <span class="n">cls</span><span class="o">.</span><span class="n">_parent_moments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_from_parent_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">u_parents</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">):</span>
            <span class="c"># Update natural parameters using parents</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_phi_from_parents</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>

            <span class="c"># Update moments</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_moments_and_cgf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span>
                                                                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="c"># TODO/FIXME/BUG: You should use observation mask in order to not</span>
            <span class="c"># overwrite them!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_moments_and_cgf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        

<div class="viewcode-block" id="ExponentialFamily.initialize_from_prior"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_prior.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_prior">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_from_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">u_parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_from_parents</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_from_parent_moments</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ExponentialFamily.initialize_from_parameters"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_parameters.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_from_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">u_parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_mom</span><span class="o">.</span><span class="n">compute_fixed_moments</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
                     <span class="k">for</span> <span class="p">(</span><span class="n">p_mom</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_moments</span><span class="p">,</span> <span class="n">args</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_from_parent_moments</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>
        
</div>
<div class="viewcode-block" id="ExponentialFamily.initialize_from_value"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_value.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_value">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_from_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># Update moments from value</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moments</span><span class="o">.</span><span class="n">compute_fixed_moments</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c"># Check that the shape is correct</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="o">-</span><span class="n">ndim</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The initial value for node </span><span class="si">%s</span><span class="s"> has invalid shape </span><span class="si">%s</span><span class="s">.&quot;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_moments_and_cgf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ExponentialFamily.initialize_from_random"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_random.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.initialize_from_random">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_from_random</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable to a random sample from the current distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#self.initialize_from_prior()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_from_value</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_update_phi_from_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">u_parents</span><span class="p">):</span>

        <span class="c"># TODO/FIXME: Could this be combined to the function</span>
        <span class="c"># _update_distribution_and_lowerbound ?</span>
        <span class="c"># No, because some initialization methods may want to use this.</span>

        <span class="c"># This makes correct broadcasting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_phi_from_parents</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>
        <span class="c">#self.phi = self._compute_phi_from_parents(*u_parents)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="c"># Make sure phi has the correct number of axes. It makes life</span>
        <span class="c"># a bit easier elsewhere.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">axes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Add axes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">add_leading_axes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Remove extra leading axes</span>
                <span class="n">first</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="n">first</span><span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sh</span><span class="p">)</span>
            <span class="c"># Check that the shape is correct</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">misc</span><span class="o">.</span><span class="n">is_shape_subset</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Incorrect shape of phi[</span><span class="si">%d</span><span class="s">] in node class </span><span class="si">%s</span><span class="s">. &quot;</span>
                                 <span class="s">&quot;Shape is </span><span class="si">%s</span><span class="s"> but it should be broadcastable &quot;</span>
                                 <span class="s">&quot;to shape </span><span class="si">%s</span><span class="s">.&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_set_moments_and_cgf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_moments</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>

        <span class="k">return</span>


<div class="viewcode-block" id="ExponentialFamily.get_riemannian_gradient"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.get_riemannian_gradient.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.get_riemannian_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">get_riemannian_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Computes the Riemannian/natural gradient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u_parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_from_parents</span><span class="p">()</span>
        <span class="n">m_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_from_children</span><span class="p">()</span>
        
        <span class="c"># TODO/FIXME: Put observed plates to zero?</span>
        <span class="c"># Compute the gradient</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_phi_from_parents</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)):</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annealing</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">m_children</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">phi</span>

</div>
<div class="viewcode-block" id="ExponentialFamily.get_gradient"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.get_gradient.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.get_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">get_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot; Computes gradient with respect to the natural parameters.</span>

<span class="sd">        The function takes the Riemannian gradient as an input.  This is for</span>
<span class="sd">        three reasons: 1) You probably want to use the Riemannian gradient</span>
<span class="sd">        anyway so this helps avoiding accidental use of this function.  2) The</span>
<span class="sd">        gradient is computed by using the Riemannian gradient and chain rules.</span>
<span class="sd">        3) Probably you need both Riemannian and normal gradients anyway so you</span>
<span class="sd">        can provide it to this function to avoid re-computing it.&quot;&quot;&quot;</span>
            
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_gradient</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)):</span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annealing</span>
        <span class="k">return</span> <span class="n">g</span>


    <span class="c">## def update_parameters(self, d, scale=1.0):</span>
    <span class="c">##     r&quot;&quot;&quot;</span>
    <span class="c">##     Update the parameters of the VB distribution given a change.</span>

    <span class="c">##     The parameters should be such that they can be used for</span>
    <span class="c">##     optimization, that is, use log transformation for positive</span>
    <span class="c">##     parameters.</span>
    <span class="c">##     &quot;&quot;&quot;</span>
    <span class="c">##     phi = self.get_parameters()</span>
    <span class="c">##     for i in range(len(phi)):</span>
    <span class="c">##         phi[i] = phi[i] + scale*d[i]</span>
    <span class="c">##     self.set_parameters(phi)</span>
    <span class="c">##     return</span>

</div>
<div class="viewcode-block" id="ExponentialFamily.get_parameters"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.get_parameters.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Return parameters of the VB distribution.</span>

<span class="sd">        The parameters should be such that they can be used for</span>
<span class="sd">        optimization, that is, use log transformation for positive</span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">]</span>
            

</div>
    <span class="k">def</span> <span class="nf">_decode_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>


<div class="viewcode-block" id="ExponentialFamily.set_parameters"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.set_parameters.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.set_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Set the parameters of the VB distribution.</span>

<span class="sd">        The parameters should be such that they can be used for</span>
<span class="sd">        optimization, that is, use log transformation for positive</span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decode_parameters</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_moments_and_cgf</span><span class="p">()</span>
        <span class="k">return</span>

</div>
    <span class="k">def</span> <span class="nf">_update_distribution_and_lowerbound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m_children</span><span class="p">,</span> <span class="o">*</span><span class="n">u_parents</span><span class="p">):</span>

        <span class="c"># Update phi first from parents..</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_phi_from_parents</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>
        <span class="c"># .. then just add children&#39;s message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">annealing</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">m_children</span><span class="p">)]</span>

        <span class="c"># Update u and g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_moments_and_cgf</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_update_moments_and_cgf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update moments and cgf based on current phi.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Mask for plates to update (i.e., unobserved plates)</span>
        <span class="n">update_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span>

        <span class="c"># Compute the moments (u) and CGF (g)...</span>
        <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_moments_and_cgf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span>
                                                            <span class="n">mask</span><span class="o">=</span><span class="n">update_mask</span><span class="p">)</span>
        <span class="c"># ... and store them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_moments_and_cgf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">update_mask</span><span class="p">)</span>
            
<div class="viewcode-block" id="ExponentialFamily.observe"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.observe.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.observe">[docs]</a>    <span class="k">def</span> <span class="nf">observe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix moments, compute f and propagate mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Compute fixed moments</span>
        <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_fixed_moments_and_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                                                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="c"># Check the dimensionality of the observations</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="c"># This is what the dimensionality &quot;should&quot; be</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plates</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Dimensionality of the observations incorrect.&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Shape of input: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Expected shape: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Check plates.&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Set the moments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_moments</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

        <span class="c"># Observed nodes should not be ignored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_mask</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ExponentialFamily.lower_bound_contribution"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.lower_bound_contribution.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.lower_bound_contribution">[docs]</a>    <span class="k">def</span> <span class="nf">lower_bound_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ignore_masked</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Compute E[ log p(X|parents) - log q(X) ]</span>

<span class="sd">        If deterministic annealing is used, the term E[ -log q(X) ] is</span>
<span class="sd">        divided by the anneling coefficient.  That is, phi and cgf of q</span>
<span class="sd">        are multiplied by the temperature (inverse annealing</span>
<span class="sd">        coefficient).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Annealing temperature</span>
        <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">annealing</span>
        
        <span class="c"># Messages from parents</span>
        <span class="n">u_parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_from_parents</span><span class="p">()</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_phi_from_parents</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>
        <span class="c"># G from parents</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_cgf_from_parents</span><span class="p">(</span><span class="o">*</span><span class="n">u_parents</span><span class="p">)</span>

        <span class="c"># G for unobserved variables (ignored variables are handled properly</span>
        <span class="c"># automatically)</span>
        <span class="n">latent_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">)</span>

        <span class="c"># G and F</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">elif</span> <span class="n">T</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span>
            <span class="c">## TRIED THIS BUT IT WAS WRONG:</span>
            <span class="c">## z = -T * self.g + (1-T) * self.f</span>
            <span class="c">## if np.any(np.isnan(self.f)):</span>
            <span class="c">##     warnings.warn(&quot;F(x) not implemented for node %s. This &quot;</span>
            <span class="c">##                   &quot;is required for annealed lower bound &quot;</span>
            <span class="c">##                   &quot;computation.&quot; % self.__class__.__name__)</span>
            <span class="c">##</span>
            <span class="c">## It was wrong because the optimal q distribution has f which is</span>
            <span class="c">## weighted by 1/T and here the f of q is weighted by T so the</span>
            <span class="c">## total weight is 1, thus it cancels out with f of p.</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">phi_p</span><span class="p">,</span> <span class="n">phi_q</span><span class="p">,</span> <span class="n">u_q</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="c"># Form a mask which puts observed variables to zero and</span>
            <span class="c"># broadcasts properly</span>
            <span class="n">latent_mask_i</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">add_trailing_axes</span><span class="p">(</span>
                                <span class="n">misc</span><span class="o">.</span><span class="n">add_leading_axes</span><span class="p">(</span>
                                    <span class="n">latent_mask</span><span class="p">,</span>
                                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">latent_mask</span><span class="p">)),</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
            <span class="n">axis_sum</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span><span class="mi">0</span><span class="p">))</span>

            <span class="c"># Compute the term</span>
            <span class="n">phi_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">latent_mask_i</span><span class="p">,</span> <span class="n">phi_q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c"># Apply annealing</span>
            <span class="c"># TODO/FIXME: Use einsum here?</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">phi_p</span><span class="o">-</span><span class="n">T</span><span class="o">*</span><span class="n">phi_q</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_sum</span><span class="p">)</span>

            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">+</span> <span class="n">Z</span>

        <span class="k">if</span> <span class="n">ignore_masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">,</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">L</span><span class="p">),</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates_multiplier</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">,</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates_multiplier</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="ExponentialFamily.logpdf"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.logpdf.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.logpdf">[docs]</a>    <span class="k">def</span> <span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the log probability density function Q(X) of this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Mask not yet implemented&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">compute_fixed_moments_and_f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">phi_d</span><span class="p">,</span> <span class="n">u_d</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">axis_sum</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span><span class="mi">0</span><span class="p">))</span>
            <span class="c"># TODO/FIXME: Use einsum here?</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">phi_d</span> <span class="o">*</span> <span class="n">u_d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_sum</span><span class="p">)</span>
            <span class="c">#Z = Z + misc.sum_multiply(phi_d, u_d, axis=axis_sum)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="n">Z</span><span class="p">)</span>
        
</div>
<div class="viewcode-block" id="ExponentialFamily.pdf"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.pdf.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the probability density function of this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">))</span>
        
</div>
    <span class="k">def</span> <span class="nf">_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the state of the node into a HDF5 file.</span>

<span class="sd">        group can be the root</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">## if name is None:</span>
        <span class="c">##     name = self.name</span>
        <span class="c">## subgroup = group.create_group(name)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)):</span>
            <span class="n">misc</span><span class="o">.</span><span class="n">write_to_hdf5</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#39;phi</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">misc</span><span class="o">.</span><span class="n">write_to_hdf5</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">)</span>
        <span class="n">misc</span><span class="o">.</span><span class="n">write_to_hdf5</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_save</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    
    <span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the state of the node from a HDF5 file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO/FIXME: Check that the shapes are correct!</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)):</span>
            <span class="n">phii</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s">&#39;phi</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phii</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>


<div class="viewcode-block" id="ExponentialFamily.random"><a class="viewcode-back" href="../../../../../dev_api/generated/generated/bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.random.html#bayespy.inference.vmp.nodes.expfamily.ExponentialFamily.random">[docs]</a>    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw a random sample from the distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distribution</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="n">plates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">BayesPy v0.4.0 Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-2015, Jaakko Luttinen, MIT.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>