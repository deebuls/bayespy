<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bayespy.inference.vmp.transformations &mdash; BayesPy v0.3.5 Documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.3.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BayesPy v0.3.5 Documentation" href="../../../../index.html" />
    <link rel="up" title="bayespy.inference" href="../../inference.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">BayesPy v0.3.5 Documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../inference.html" accesskey="U">bayespy.inference</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for bayespy.inference.vmp.transformations</h1><div class="highlight"><pre>
<span class="c">################################################################################</span>
<span class="c"># Copyright (C) 2013-2014 Jaakko Luttinen</span>
<span class="c">#</span>
<span class="c"># This file is licensed under the MIT License.</span>
<span class="c">################################################################################</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="kn">from</span> <span class="nn">bayespy.utils</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">bayespy.utils</span> <span class="kn">import</span> <span class="n">random</span>
<span class="kn">from</span> <span class="nn">bayespy.utils</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">bayespy.utils</span> <span class="kn">import</span> <span class="n">misc</span>

<span class="kn">from</span> <span class="nn">bayespy.utils.linalg</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">tracedot</span>

<span class="kn">from</span> <span class="nn">.nodes</span> <span class="kn">import</span> <span class="n">gaussian</span>

<span class="kn">from</span> <span class="nn">.nodes.categorical</span> <span class="kn">import</span> <span class="n">CategoricalMoments</span>

<div class="viewcode-block" id="RotationOptimizer"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotationOptimizer.html#bayespy.inference.vmp.transformations.RotationOptimizer">[docs]</a><span class="k">class</span> <span class="nc">RotationOptimizer</span><span class="p">():</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Optimizer for rotation parameter expansion in state-space models</span>

<span class="sd">    Rotates one model block with :math:`\mathbf{R}` and one model block with</span>
<span class="sd">    :math:`\mathbf{R}^{-1}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    block1 : rotator object</span>

<span class="sd">        The first rotation parameter expansion object</span>

<span class="sd">    block2 : rotator object</span>

<span class="sd">        The second rotation parameter expansion object</span>

<span class="sd">    D : int</span>

<span class="sd">        Dimensionality of the latent space</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    :cite:`Luttinen:2010`, :cite:`Luttinen:2013`</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RotationOptimizer.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotationOptimizer.__init__.html#bayespy.inference.vmp.transformations.RotationOptimizer.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">block2</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block1</span> <span class="o">=</span> <span class="n">block1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block2</span> <span class="o">=</span> <span class="n">block2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span>
</div>
<div class="viewcode-block" id="RotationOptimizer.rotate"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotationOptimizer.rotate.html#bayespy.inference.vmp.transformations.RotationOptimizer.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
               <span class="n">maxiter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
               <span class="n">check_gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">check_bound</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the rotation of two separate model blocks jointly.</span>

<span class="sd">        If some variable is the dot product of two Gaussians, rotating the two</span>
<span class="sd">        Gaussians optimally can make the inference algorithm orders of magnitude</span>
<span class="sd">        faster.</span>

<span class="sd">        First block is rotated with :math:`\mathbf{R}` and the second with</span>
<span class="sd">        :math:`\mathbf{R}^{-T}`.</span>

<span class="sd">        Blocks must have methods: `bound(U,s,V)` and `rotate(R)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">piv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>

            <span class="c"># Make vector-r into matrix-R</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span>

            <span class="c"># Compute SVD</span>
            <span class="n">invR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
            <span class="n">logdetR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># Compute lower bound terms</span>
            <span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="n">db1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block1</span><span class="o">.</span><span class="n">bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="n">logdetR</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">invR</span><span class="p">)</span>
            <span class="p">(</span><span class="n">b2</span><span class="p">,</span><span class="n">db2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block2</span><span class="o">.</span><span class="n">bound</span><span class="p">(</span><span class="n">invR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=-</span><span class="n">logdetR</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c"># Apply chain rule for the second gradient:</span>
            <span class="c"># d b(invR.T) </span>
            <span class="c"># = tr(db.T * d(invR.T)) </span>
            <span class="c"># = tr(db * d(invR))</span>
            <span class="c"># = -tr(db * invR * (dR) * invR) </span>
            <span class="c"># = -tr(invR * db * invR * dR)</span>
            <span class="n">db2</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">invR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">db2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">invR</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c"># Compute the cost function</span>
            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">b1</span><span class="o">+</span><span class="n">b2</span><span class="p">)</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">db1</span><span class="o">+</span><span class="n">db2</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">dc</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">get_bound_terms</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a dictionary of bound terms for the nodes.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c"># Gradient not yet implemented..</span>
            <span class="k">if</span> <span class="n">gradient</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
            
            <span class="c"># Make vector-r into matrix-R</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span>

            <span class="c"># Compute SVD</span>
            <span class="n">invR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
            <span class="n">logdetR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># Compute lower bound terms</span>
            <span class="n">dict1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block1</span><span class="o">.</span><span class="n">get_bound_terms</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> 
                                                <span class="n">logdet</span><span class="o">=</span><span class="n">logdetR</span><span class="p">,</span> 
                                                <span class="n">inv</span><span class="o">=</span><span class="n">invR</span><span class="p">)</span>
            <span class="n">dict2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block2</span><span class="o">.</span><span class="n">get_bound_terms</span><span class="p">(</span><span class="n">invR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                                                <span class="n">logdet</span><span class="o">=-</span><span class="n">logdetR</span><span class="p">,</span> 
                                                <span class="n">inv</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">gradient</span><span class="p">:</span>
                <span class="n">dict1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dict2</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dict1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">dict1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dict2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="n">dict1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dict2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_true_bound_terms</span><span class="p">():</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block1</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block2</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">D</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c"># TODO/FIXME: Also compute bound for child nodes as they could be</span>
            <span class="c"># affected in practice although they shouldn&#39;t. Just checking that.</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">lower_bound_contribution</span><span class="p">()</span>
                <span class="n">D</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span>
            <span class="k">return</span> <span class="n">D</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">block1</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block2</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">check_gradient</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">check_gradient</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> 
                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Rotation gradient has relative error </span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>

        <span class="c"># Initial rotation is identity matrix</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span>

        <span class="p">(</span><span class="n">cost_begin</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_bound</span><span class="p">:</span>
            <span class="n">bound_terms_begin</span> <span class="o">=</span> <span class="n">get_bound_terms</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
            <span class="n">true_bound_terms_begin</span> <span class="o">=</span> <span class="n">get_true_bound_terms</span><span class="p">()</span>

        <span class="c"># Run optimization</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="p">(</span><span class="n">cost_end</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_bound</span><span class="p">:</span>
            <span class="n">bound_terms_end</span> <span class="o">=</span> <span class="n">get_bound_terms</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="c"># Apply the optimal rotation</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">))</span>
        <span class="n">invR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">logdetR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block1</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">invR</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="n">logdetR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">invR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=-</span><span class="n">logdetR</span><span class="p">)</span>

        <span class="c"># Check that the cost function and the true lower bound changed equally</span>
        <span class="n">cost_change</span> <span class="o">=</span> <span class="n">cost_end</span> <span class="o">-</span> <span class="n">cost_begin</span>
        
        <span class="c"># Check that we really have improved the bound.</span>
        <span class="k">if</span> <span class="n">cost_change</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Rotation optimization made the cost function worse &quot;</span>
                          <span class="s">&quot;by </span><span class="si">%g</span><span class="s">. Probably a bug in the gradient of the &quot;</span>
                          <span class="s">&quot;rotation functions.&quot;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="n">cost_change</span><span class="p">,))</span>
                
        <span class="k">if</span> <span class="n">check_bound</span><span class="p">:</span>
            <span class="n">true_bound_terms_end</span> <span class="o">=</span> <span class="n">get_true_bound_terms</span><span class="p">()</span>
            <span class="n">bound_change</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">bound_terms_begin</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">node_bound_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">bound_terms_end</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> 
                                    <span class="o">-</span> <span class="n">bound_terms_begin</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
                <span class="n">bound_change</span> <span class="o">+=</span> <span class="n">node_bound_change</span>
                <span class="n">true_node_bound_change</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">true_node_bound_change</span> <span class="o">+=</span> <span class="p">(</span><span class="n">true_bound_terms_end</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> 
                                               <span class="o">-</span> <span class="n">true_bound_terms_begin</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The node </span><span class="si">%s</span><span class="s"> is part of the &quot;</span>
                                    <span class="s">&quot;transformation but not part of the &quot;</span>
                                    <span class="s">&quot;model. Check your VB construction.&quot;</span> 
                                    <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">node_bound_change</span><span class="p">,</span> <span class="n">true_node_bound_change</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Rotation cost function is not consistent &quot;</span>
                                  <span class="s">&quot;with the true lower bound for node </span><span class="si">%s</span><span class="s">. &quot;</span>
                                  <span class="s">&quot;Bound changed </span><span class="si">%g</span><span class="s"> but optimized function &quot;</span>
                                  <span class="s">&quot;changed </span><span class="si">%g</span><span class="s">.&quot;</span>  
                                  <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                     <span class="n">true_node_bound_change</span><span class="p">,</span>
                                     <span class="n">node_bound_change</span><span class="p">))</span>

            <span class="c"># Check that we really have improved the bound.</span>
            <span class="c"># TODO/FIXME: Also compute bound for child nodes as they could be</span>
            <span class="c"># affected in practice although they shouldn&#39;t. Just checking that.</span>
            <span class="k">if</span> <span class="n">bound_change</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Rotation made the true lower bound worse by </span><span class="si">%g</span><span class="s">. &quot;</span>
                              <span class="s">&quot;Probably a bug in the rotation functions.&quot;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="n">bound_change</span><span class="p">,))</span>
                
</div></div>
<div class="viewcode-block" id="RotateGaussian"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.html#bayespy.inference.vmp.transformations.RotateGaussian">[docs]</a><span class="k">class</span> <span class="nc">RotateGaussian</span><span class="p">():</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Rotation parameter expansion for :class:`bayespy.nodes.Gaussian`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RotateGaussian.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.__init__.html#bayespy.inference.vmp.transformations.RotateGaussian.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
</div>
<div class="viewcode-block" id="RotateGaussian.rotate"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.rotate.html#bayespy.inference.vmp.transformations.RotateGaussian.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RotateGaussian.setup"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.setup.html#bayespy.inference.vmp.transformations.RotateGaussian.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should be called just before optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c"># Number of plates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">plates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#np.sum(mask)</span>

        <span class="c"># Compute the sum &lt;XX&gt; over plates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">XX</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">mask</span><span class="p">,</span>
                                    <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                    <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                    <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c"># Parent&#39;s moments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">_compute_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate q(X) as X-&gt;RX: q(X)=N(R*mu, R*Cov*R&#39;)</span>

<span class="sd">        Assume:</span>
<span class="sd">        :math:`p(\mathbf{X}) = \prod^M_{m=1} </span>
<span class="sd">               N(\mathbf{x}_m|0, \mathbf{\Lambda})`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO/FIXME: X and alpha should NOT contain observed values!! Check</span>
        <span class="c"># that.</span>

        <span class="c"># TODO/FIXME: Allow non-zero prior mean!</span>

        <span class="c"># Assume constant mean and precision matrix over plates..</span>

        <span class="c"># Compute rotated moments</span>
        <span class="n">XX_R</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">XX</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">inv_R</span> <span class="o">=</span> <span class="n">inv</span>
        <span class="n">logdet_R</span> <span class="o">=</span> <span class="n">logdet</span>

        <span class="c"># Compute entropy H(X)</span>
        <span class="n">logH_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">*</span><span class="n">logdet_R</span><span class="p">,</span> 
                                         <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute &lt;log p(X)&gt;</span>
        <span class="n">logp_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">XX_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">),</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute the bound</span>
        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">:</span> <span class="n">bound</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">logp_X</span> <span class="o">+</span> <span class="n">logH_X</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gradient</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bound</span>

        <span class="c"># Compute dH(X)</span>
        <span class="n">dlogH_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">*</span><span class="n">inv_R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                          <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute d&lt;log p(X)&gt;</span>
        <span class="n">dXX</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">XX</span><span class="p">)</span>
        <span class="n">dlogp_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">dXX</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">d_bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">:</span> <span class="n">dlogp_X</span> <span class="o">+</span> <span class="n">dlogH_X</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_bound</span> <span class="o">=</span> <span class="n">dlogp_X</span> <span class="o">+</span> <span class="n">dlogH_X</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">d_bound</span><span class="p">)</span>


<div class="viewcode-block" id="RotateGaussian.bound"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.bound.html#bayespy.inference.vmp.transformations.RotateGaussian.bound">[docs]</a>    <span class="k">def</span> <span class="nf">bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> 
                                   <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span>
                                   <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span>
                                   <span class="n">gradient</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RotateGaussian.get_bound_terms"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.get_bound_terms.html#bayespy.inference.vmp.transformations.RotateGaussian.get_bound_terms">[docs]</a>    <span class="k">def</span> <span class="nf">get_bound_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> 
                                   <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span>
                                   <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span>
                                   <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                   <span class="n">terms</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="RotateGaussian.nodes"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussian.nodes.html#bayespy.inference.vmp.transformations.RotateGaussian.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">]</span>


    </div></div>
<span class="k">def</span> <span class="nf">covariance_to_variance</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">covariance_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># Force None to empty list</span>
    <span class="k">if</span> <span class="n">covariance_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">covariance_axis</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Force a list from integer</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covariance_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">covariance_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">covariance_axis</span><span class="p">]</span>

    <span class="c"># Force positive axis indices</span>
    <span class="n">covariance_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="n">ndim</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span> 
                       <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">covariance_axis</span><span class="p">]</span>
    
    <span class="c"># Make a set of the axes</span>
    <span class="n">covariance_axis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">covariance_axis</span><span class="p">)</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">ndim</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">covariance_axis</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)]</span>
    <span class="n">keys</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">covariance_axis</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)]</span>
    <span class="n">out_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span><span class="o">+</span><span class="n">keys</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span><span class="o">+</span><span class="n">out_keys</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sum_to_plates</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">plates_to</span><span class="p">,</span> <span class="n">plates_from</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">plates_from</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">Gaussian</span><span class="o">.</span><span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="n">plates_from</span><span class="p">,</span>
                                                          <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_to_shape</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">plates_to</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dims_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">V</span><span class="p">)[</span><span class="o">-</span><span class="n">ndim</span><span class="p">:]</span>
        <span class="n">plates_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">V</span><span class="p">)[:</span><span class="o">-</span><span class="n">ndim</span><span class="p">]</span>
        <span class="n">shape_to</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">plates_to</span><span class="p">)</span> <span class="o">+</span> <span class="n">dims_V</span>
        <span class="k">if</span> <span class="n">plates_from</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">Gaussian</span><span class="o">.</span><span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="n">plates_from</span><span class="p">,</span> <span class="n">plates_V</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_to_shape</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">shape_to</span><span class="p">)</span>

<div class="viewcode-block" id="RotateGaussianARD"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.html#bayespy.inference.vmp.transformations.RotateGaussianARD">[docs]</a><span class="k">class</span> <span class="nc">RotateGaussianARD</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotation parameter expansion for :class:`bayespy.nodes.GaussianARD`</span>
<span class="sd">    </span>
<span class="sd">    The model:</span>

<span class="sd">    alpha ~ N(a, b)</span>
<span class="sd">    X ~ N(mu, alpha)</span>

<span class="sd">    X can be an array (e.g., GaussianARD).</span>

<span class="sd">    Transform q(X) and q(alpha) by rotating X.</span>

<span class="sd">    Requirements:</span>
<span class="sd">    * X and alpha do not contain any observed values</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="RotateGaussianARD.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.__init__.html#bayespy.inference.vmp.transformations.RotateGaussianARD.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">precompute</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Precompute tells whether to compute some moments once in the setup</span>
<span class="sd">        function instead of every time in the bound function.  However, they are</span>
<span class="sd">        computed a bit differently in the bound function so it can be useful</span>
<span class="sd">        too. Precomputation is probably beneficial only when there are large</span>
<span class="sd">        axes that are not rotated (by R nor Q) and they are not contained in the</span>
<span class="sd">        plates of alpha, and the dimensions for R and Q are quite small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">precompute</span> <span class="o">=</span> <span class="n">precompute</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">node_parent</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Too many arguments&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="c">#self.node_mu = X.parents[0]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c"># Force negative rotation axis indexing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Axis must be integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Axis out of bounds&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>

        <span class="c"># Allow rotation of only subset of elements/slices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c">#self.subset = np.ones(self.D, dtype=bool)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subset</span> <span class="o">=</span> <span class="bp">None</span> <span class="c">#tuple(range(self.D))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#self.subset = tuple(range(self.D))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subset</span> <span class="o">=</span> <span class="n">subset</span> <span class="c">#self.subset[subset]</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Subset indexing for non-last &quot;</span>
                                          <span class="s">&quot;axis not yet implemented&quot;</span><span class="p">)</span>
            <span class="c">## self.subset = np.zeros(self.D, dtype=bool)</span>
            <span class="c">## self.subset[list(subset)] = True</span>

</div>
<div class="viewcode-block" id="RotateGaussianARD.nodes"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.nodes.html#bayespy.inference.vmp.transformations.RotateGaussianARD.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="p">]</span>

</div>
    <span class="k">def</span> <span class="nf">_full_rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">R_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span>
            <span class="n">R_full</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
            <span class="k">return</span> <span class="n">R_full</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">R</span>


<div class="viewcode-block" id="RotateGaussianARD.rotate"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.rotate.html#bayespy.inference.vmp.transformations.RotateGaussianARD.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="c">## R = self._full_rotation_matrix(R)</span>
        <span class="c">## if inv is not None:</span>
        <span class="c">##     inv = self._full_rotation_matrix(inv)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> 
                           <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span>
                           <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span>
                           <span class="n">subset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">,</span>
                           <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">rotate_plates</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">plate_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">plate_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RotateGaussianARD.setup"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.setup.html#bayespy.inference.vmp.transformations.RotateGaussianARD.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plate_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should be called just before optimization.</span>

<span class="sd">        For efficiency, sum over axes that are not in mu, alpha nor rotation.</span>

<span class="sd">        If using Q, set rotate_plates to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Store the original plate_axis parameter for later use in other methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plate_axis</span> <span class="o">=</span> <span class="n">plate_axis</span>

        <span class="c"># Manipulate the plate_axis parameter to suit the needs of this method</span>
        <span class="k">if</span> <span class="n">plate_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plate_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Plate axis must be integer&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plate_axis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plate_axis</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plate_axis</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="ow">or</span> <span class="n">plate_axis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Axis out of bounds&quot;</span><span class="p">)</span>
            <span class="n">plate_axis</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="c"># Why -1? Because one axis is preserved!</span>
                
        <span class="c"># Get the mean parameter. It will not be rotated. This assumes that mu</span>
        <span class="c"># and alpha are really independent.</span>
        <span class="p">(</span><span class="n">alpha_mu</span><span class="p">,</span> <span class="n">alpha_mu2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_parent</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">XX</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>

        <span class="c">#</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">alpha_mu</span> <span class="o">/</span> <span class="n">alpha</span>
        <span class="n">mu2</span> <span class="o">=</span> <span class="n">alpha_mu2</span> <span class="o">/</span> <span class="n">alpha</span>
        <span class="c"># For simplicity, force mu to have the same shape as X</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c">## (mu, mumu) = gaussian.reshape_gaussian_array(self.node_mu.dims[0],</span>
        <span class="c">##                                              self.node_X.dims[0],</span>
        <span class="c">##                                              mu,</span>
        <span class="c">##                                              mumu)</span>

        <span class="c"># Take diagonal of covariances to variances for axes that are not in R</span>
        <span class="c"># (and move those axes to be the last)</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="n">covariance_to_variance</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span>
                                    <span class="n">ndim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                    <span class="n">covariance_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="c">## mumu = covariance_to_variance(mumu,</span>
        <span class="c">##                               ndim=self.ndim, </span>
        <span class="c">##                               covariance_axis=self.axis)</span>
        
        <span class="c"># Move axes of X and mu and compute their outer product</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mu2</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Xmu</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c"># Move axes of alpha related variables</span>
        <span class="k">def</span> <span class="nf">safe_move_axis</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">misc</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">safe_move_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="n">safe_move_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">b0</span> <span class="o">=</span> <span class="n">safe_move_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">plates_alpha</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">safe_move_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_parent</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">plates_alpha</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_parent</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="c"># Move plates of alpha for R</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plates_alpha</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">:</span>
            <span class="n">plate</span> <span class="o">=</span> <span class="n">plates_alpha</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">plates_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plates_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="n">plates_X</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">plates_X</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">sum_to_alpha</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="c"># TODO/FIXME: This could be improved so that it is not required to</span>
            <span class="c"># explicitly repeat to alpha plates. Multiplying by ones was just a</span>
            <span class="c"># simple bug fix.</span>
            <span class="k">return</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">V</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                 <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">ndim</span><span class="o">=</span><span class="n">ndim</span><span class="p">,</span>
                                 <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plate_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Move plate axis just before the rotated dimensions (which are</span>
            <span class="c"># last)</span>
            <span class="k">def</span> <span class="nf">safe_move_plate_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">plate_axis</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">misc</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> 
                                         <span class="n">plate_axis</span><span class="o">-</span><span class="n">ndim</span><span class="p">,</span>
                                         <span class="o">-</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inds</span> <span class="o">=</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span> <span class="o">+</span> <span class="n">ndim</span><span class="o">*</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),)</span>
                    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">XX</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">mu2</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">a0</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">b0</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">safe_move_plate_axis</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c"># Move plates of X and alpha</span>
            <span class="n">plate</span> <span class="o">=</span> <span class="n">plates_X</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">plate_axis</span><span class="p">)</span>
            <span class="n">plates_X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plate</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plates_alpha</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">plate_axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">plate</span> <span class="o">=</span> <span class="n">plates_alpha</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">plate_axis</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plate</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">plates_alpha</span> <span class="o">=</span> <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">plate</span><span class="p">]</span> <span class="o">+</span> <span class="n">plates_alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">CovX</span> <span class="o">=</span> <span class="n">XX</span> <span class="o">-</span> <span class="n">linalg</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CovX</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">CovX</span><span class="p">,</span>
                                      <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                                      <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                      <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c"># Broadcast mumu to ensure shape</span>
            <span class="c">#mumu = np.ones(np.shape(XX)[-3:]) * mumu</span>
            <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu2</span> <span class="o">=</span> <span class="n">sum_to_alpha</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precompute</span><span class="p">:</span>
                <span class="c"># Precompute some stuff for the gradient of plate rotation</span>
                <span class="c">#</span>
                <span class="c"># NOTE: These terms may require a lot of memory if alpha has the</span>
                <span class="c"># same or almost the same plates as X.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_X</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span>
                                         <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,:,:],</span>
                                         <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                                         <span class="n">ndim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                         <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_mu</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span>
                                          <span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,:,:],</span>
                                          <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                                          <span class="n">ndim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                          <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
                    
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Sum axes that are not in the plates of alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">XX</span> <span class="o">=</span> <span class="n">sum_to_alpha</span><span class="p">(</span><span class="n">XX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu2</span> <span class="o">=</span> <span class="n">sum_to_alpha</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xmu</span> <span class="o">=</span> <span class="n">sum_to_alpha</span><span class="p">(</span><span class="n">Xmu</span><span class="p">)</span>
            
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="o">=</span> <span class="n">a0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b0</span> <span class="o">=</span> <span class="n">b0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plates_X</span> <span class="o">=</span> <span class="n">plates_X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plates_alpha</span> <span class="o">=</span> <span class="n">plates_alpha</span>

        <span class="c"># Take only a subset of the matrix for rotation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precompute</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Precomputation not implemented when &quot;</span>
                                          <span class="s">&quot;using a subset&quot;</span><span class="p">)</span>
            <span class="c"># from X</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">plate_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># from CovX</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CovX</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CovX</span><span class="p">)[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span>
                <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">inds</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">CovX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CovX</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="c"># from mu</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># from XX</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XX</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XX</span><span class="p">)[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span>
                <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">inds</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">XX</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="c"># from Xmu</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Xmu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xmu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
            <span class="c"># from alpha</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a0</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b0</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">b0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">plates_alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plates_alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">))</span>
        <span class="c">##     # from mu</span>
        <span class="c">##     # from alpha</span>
        <span class="c">##     alpha_mu = alpha_mu[...,self.subset]</span>
        <span class="c">##     alpha_mu2 = alpha_mu2[...,self.subset]</span>
        <span class="c">##     alpha = alpha[...,self.subset]</span>
        <span class="c">##     dims = list(self.node_X.dims[0])</span>
        <span class="c">##     dims[-1] = len(self.subset)</span>
        <span class="c">## else:</span>
        <span class="c">##     dims = list(self.node_X.dims[0])</span>

</div>
    <span class="k">def</span> <span class="nf">_compute_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate q(X) and q(alpha).</span>

<span class="sd">        Assume:</span>
<span class="sd">        p(X|alpha) = prod_m N(x_m|0,diag(alpha))</span>
<span class="sd">        p(alpha) = prod_d G(a_d,b_d)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">## R = self._full_rotation_matrix(R)</span>
        <span class="c">## if inv is not None:</span>
        <span class="c">##     inv = self._full_rotation_matrix(inv)</span>

        <span class="c">#</span>
        <span class="c"># Transform the distributions and moments</span>
        <span class="c">#</span>

        <span class="n">plates_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plates_alpha</span>
        <span class="n">plates_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plates_X</span>
        
        <span class="c"># Compute rotated second moment</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># The plate axis has been moved to be the last plate axis</span>

            <span class="k">if</span> <span class="n">Q</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Plates should be rotated but no Q give&quot;</span><span class="p">)</span>

            <span class="c"># Transform covariance</span>
            <span class="n">sumQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">QCovQ</span> <span class="o">=</span> <span class="n">sumQ</span><span class="p">[:,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CovX</span>
            
            <span class="c"># Rotate plates</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precompute</span><span class="p">:</span>
                <span class="n">QX_QX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kalb,...ik,...il-&gt;...iab&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_X</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
                <span class="n">XX</span> <span class="o">=</span> <span class="n">QX_QX</span> <span class="o">+</span> <span class="n">QCovQ</span>
                <span class="n">XX</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span>
                                   <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Xmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kaib,...ik-&gt;...iab&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_mu</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
                <span class="n">Xmu</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">Xmu</span><span class="p">,</span>
                                   <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
                <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span>
                <span class="n">QX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...kj-&gt;...ij&#39;</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                <span class="n">XX</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_to_plates</span><span class="p">(</span><span class="n">QCovQ</span><span class="p">,</span>
                                    <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                      <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">QX</span><span class="p">,</span> <span class="n">QX</span><span class="p">),</span>
                                    <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">))</span>
                <span class="n">Xmu</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">QX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">),</span>
                                    <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">)</span>

            <span class="n">mu2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu2</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">XX</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">logdet_Q</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumQ</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">XX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">XX</span>
            <span class="n">mu2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu2</span>
            <span class="n">Xmu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xmu</span>
            <span class="n">logdet_Q</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Compute transformed moments</span>
        <span class="c">#mu2 = np.einsum(&#39;...ii-&gt;...i&#39;, mu2)</span>
        <span class="n">RXmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...ki-&gt;...i&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Xmu</span><span class="p">)</span>
        <span class="n">RXX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...kj-&gt;...ij&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">XX</span><span class="p">)</span>
        <span class="n">RXXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...ik-&gt;...i&#39;</span><span class="p">,</span> <span class="n">RXX</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

        <span class="c"># &lt;(X-mu) * (X-mu)&#39;&gt;_R</span>
        <span class="n">XmuXmu</span> <span class="o">=</span> <span class="p">(</span><span class="n">RXXR</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">RXmu</span> <span class="o">+</span> <span class="n">mu2</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># Compute q(alpha)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="c"># Parameters</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span>
            <span class="n">b0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b0</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">sum_to_plates</span><span class="p">(</span><span class="n">XmuXmu</span><span class="p">,</span>
                                       <span class="n">plates_alpha</span><span class="p">,</span>
                                       <span class="n">plates_from</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                       <span class="n">ndim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c"># Some expectations</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
            <span class="n">logb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">logalpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">logb</span> <span class="c"># + const</span>
            <span class="n">b0_alpha</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">alpha</span>
            <span class="n">a0_logalpha</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">logalpha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            <span class="n">logalpha</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c">#</span>
        <span class="c"># Compute the cost</span>
        <span class="c">#</span>

        <span class="k">def</span> <span class="nf">sum_plates</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="o">*</span><span class="n">plates</span><span class="p">):</span>
            <span class="n">full_plates</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">broadcasted_shape</span><span class="p">(</span><span class="o">*</span><span class="n">plates</span><span class="p">)</span>
            
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="n">full_plates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

        <span class="n">XmuXmu_alpha</span> <span class="o">=</span> <span class="n">XmuXmu</span> <span class="o">*</span> <span class="n">alpha</span>

        <span class="k">if</span> <span class="n">logdet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logdet_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">inv_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logdet_R</span> <span class="o">=</span> <span class="n">logdet</span>
            <span class="n">inv_R</span> <span class="o">=</span> <span class="n">inv</span>

        <span class="c"># Compute entropy H(X)</span>
        <span class="n">logH_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">logdet_R</span> <span class="o">+</span> <span class="n">logdet_Q</span><span class="p">,</span>
                                                             <span class="n">plates_X</span><span class="p">),</span>
                                               <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute &lt;log p(X|alpha)&gt;</span>
        <span class="n">logp_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">XmuXmu_alpha</span><span class="p">,</span>
                                                         <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">D</span><span class="p">]),</span>
                                              <span class="mi">0</span><span class="p">,</span>
                                              <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">sum_plates</span><span class="p">(</span><span class="n">logalpha</span><span class="p">,</span>
                                                         <span class="n">plates_X</span> <span class="o">+</span> <span class="p">[</span><span class="n">D</span><span class="p">]),</span>
                                              <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>

            <span class="c"># Compute entropy H(alpha)</span>
            <span class="c"># This cancels out with the log(alpha) term in log(p(alpha))</span>
            <span class="n">logH_alpha</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># Compute &lt;log p(alpha)&gt;</span>
            <span class="n">logp_alpha</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gamma_logpdf</span><span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">b0_alpha</span><span class="p">,</span>
                                                        <span class="n">plates_alpha</span><span class="p">),</span>
                                             <span class="mi">0</span><span class="p">,</span>
                                             <span class="n">sum_plates</span><span class="p">(</span><span class="n">a0_logalpha</span><span class="p">,</span>
                                                        <span class="n">plates_alpha</span><span class="p">),</span>
                                             <span class="mi">0</span><span class="p">,</span>
                                             <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logH_alpha</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logp_alpha</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Compute the bound</span>
        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="p">:</span> <span class="n">logp_X</span> <span class="o">+</span> <span class="n">logH_X</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
                <span class="n">bound</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="p">:</span> <span class="n">logp_alpha</span> <span class="o">+</span> <span class="n">logH_alpha</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span>
            <span class="o">+</span> <span class="n">logp_X</span>
            <span class="o">+</span> <span class="n">logp_alpha</span>
            <span class="o">+</span> <span class="n">logH_X</span>
            <span class="o">+</span> <span class="n">logH_alpha</span>
                     <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gradient</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bound</span>

        <span class="c">#</span>
        <span class="c"># Compute the gradient with respect R</span>
        <span class="c">#</span>

        <span class="n">broadcasting_multiplier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">broadcasting_multiplier</span>
        <span class="k">def</span> <span class="nf">sum_plates</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">plates</span><span class="p">):</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="n">plates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">V</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span>
                                         <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                         <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">D_XmuXmu</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">RXX</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">gaussian</span><span class="o">.</span><span class="n">transpose_covariance</span><span class="p">(</span><span class="n">Xmu</span><span class="p">)</span>

        <span class="n">DXmuXmu_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...i,...ij-&gt;...ij&#39;</span><span class="p">,</span> 
                                  <span class="n">alpha</span><span class="p">,</span>
                                  <span class="n">D_XmuXmu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="n">D_b</span>            <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">D_XmuXmu</span>
            <span class="n">XmuXmu_Dalpha</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...i,...i,...i,...ij-&gt;...ij&#39;</span><span class="p">,</span> 
                                       <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">XmuXmu</span><span class="p">,</span>
                                                     <span class="n">plates_alpha</span><span class="p">,</span>
                                                     <span class="n">plates_from</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                                     <span class="n">ndim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> 
                                       <span class="n">alpha</span><span class="p">,</span> 
                                       <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">b</span><span class="p">,</span> 
                                       <span class="n">D_b</span><span class="p">)</span>
            <span class="n">D_b0_alpha</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...i,...i,...i,...ij-&gt;...ij&#39;</span><span class="p">,</span> 
                                       <span class="n">b0</span><span class="p">,</span>
                                       <span class="n">alpha</span><span class="p">,</span>
                                       <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">b</span><span class="p">,</span>
                                       <span class="n">D_b</span><span class="p">)</span>
            <span class="n">D_logb</span>         <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...i,...ij-&gt;...ij&#39;</span><span class="p">,</span> 
                                       <span class="mi">1</span><span class="o">/</span><span class="n">b</span><span class="p">,</span>
                                       <span class="n">D_b</span><span class="p">)</span>
            <span class="n">D_logalpha</span>     <span class="o">=</span> <span class="o">-</span><span class="n">D_logb</span>
            <span class="n">D_a0_logalpha</span>  <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">D_logalpha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XmuXmu_Dalpha</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">D_logalpha</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">D_XmuXmu_alpha</span> <span class="o">=</span> <span class="n">DXmuXmu_alpha</span> <span class="o">+</span> <span class="n">XmuXmu_Dalpha</span>
        <span class="n">D_logR</span>         <span class="o">=</span> <span class="n">inv_R</span><span class="o">.</span><span class="n">T</span>
        
        
        <span class="c"># Compute dH(X)</span>
        <span class="n">dlogH_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_logR</span><span class="p">,</span>
                                                        <span class="n">plates_X</span><span class="p">),</span>
                                          <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute d&lt;log p(X|alpha)&gt;</span>
        <span class="n">dlogp_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_XmuXmu_alpha</span><span class="p">,</span>
                                                    <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                         <span class="mi">0</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">,</span>
                                         <span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_logalpha</span><span class="p">,</span>
                                                     <span class="n">plates_X</span><span class="p">)</span>
                                          <span class="o">*</span> <span class="n">broadcasting_multiplier</span><span class="p">((</span><span class="n">D</span><span class="p">,),</span>
                                                             <span class="n">plates_alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])),</span>
                                         <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>

            <span class="c"># Compute dH(alpha)</span>
            <span class="c"># This cancels out with the log(alpha) term in log(p(alpha))</span>
            <span class="n">dlogH_alpha</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># Compute d&lt;log p(alpha)&gt;</span>
            <span class="n">dlogp_alpha</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gamma_logpdf</span><span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_b0_alpha</span><span class="p">,</span>
                                                         <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                              <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">sum_plates</span><span class="p">(</span><span class="n">D_a0_logalpha</span><span class="p">,</span>
                                                         <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                              <span class="mi">0</span><span class="p">,</span>
                                              <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dlogH_alpha</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">dlogp_alpha</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
            <span class="n">dR_bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="p">:</span> <span class="n">dlogp_X</span> <span class="o">+</span> <span class="n">dlogH_X</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
                <span class="n">dR_bound</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="p">:</span> <span class="n">dlogp_alpha</span> <span class="o">+</span> <span class="n">dlogH_alpha</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dR_bound</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">dlogp_X</span>
            <span class="o">+</span> <span class="n">dlogp_X</span>
            <span class="o">+</span> <span class="n">dlogp_alpha</span>
            <span class="o">+</span> <span class="n">dlogH_X</span>
            <span class="o">+</span> <span class="n">dlogH_alpha</span>
                        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">)</span>
            <span class="n">dR_bound</span> <span class="o">=</span> <span class="n">dR_bound</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plate_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">dR_bound</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># Compute the gradient with respect to Q (if Q given)</span>
        <span class="c">#</span>

        <span class="c"># Some pre-computations</span>
        <span class="n">Q_RCovR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...kl,...il,...-&gt;...i&#39;</span><span class="p">,</span> 
                            <span class="n">R</span><span class="p">,</span> 
                            <span class="bp">self</span><span class="o">.</span><span class="n">CovX</span><span class="p">,</span>
                            <span class="n">R</span><span class="p">,</span> 
                            <span class="n">sumQ</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precompute</span><span class="p">:</span>
            <span class="n">Xr_rX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...abcd,...jb,...jd-&gt;...jac&#39;</span><span class="p">,</span> 
                               <span class="bp">self</span><span class="o">.</span><span class="n">X_X</span><span class="p">,</span> 
                               <span class="n">R</span><span class="p">,</span> 
                               <span class="n">R</span><span class="p">)</span>
            <span class="n">QXr_rX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...akj,...ik-&gt;...aij&#39;</span><span class="p">,</span> 
                               <span class="n">Xr_rX</span><span class="p">,</span> 
                               <span class="n">Q</span><span class="p">)</span>
            <span class="n">RX_mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...jk,...akbj-&gt;...jab&#39;</span><span class="p">,</span> 
                              <span class="n">R</span><span class="p">,</span> 
                              <span class="bp">self</span><span class="o">.</span><span class="n">X_mu</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">RX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...k-&gt;...i&#39;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">QXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...kj-&gt;...ij&#39;</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">RX</span><span class="p">)</span>
            <span class="n">QXr_rX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...jk-&gt;...kij&#39;</span><span class="p">,</span> <span class="n">QXR</span><span class="p">,</span> <span class="n">RX</span><span class="p">)</span>
            <span class="n">RX_mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...jk-&gt;...kij&#39;</span><span class="p">,</span> <span class="n">RX</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

            <span class="n">QXr_rX</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">QXr_rX</span><span class="p">,</span>
                                   <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                   <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">RX_mu</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">RX_mu</span><span class="p">,</span>
                                  <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                                  <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                  <span class="n">plates_from</span><span class="o">=</span><span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute: d/dQ 1/2*trace(diag(v)*&lt;(X-mu)*(X-mu)&gt;)</span>

<span class="sd">            = Q*&lt;X&gt;&#39;*R&#39;*diag(v)*R*&lt;X&gt; + ones * Q diag( tr(R&#39;*diag(v)*R*Cov) ) </span>
<span class="sd">              + mu*diag(v)*R*&lt;X&gt;</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c"># Precompute all terms to plates_alpha because v has shape</span>
            <span class="c"># plates_alpha.</span>

            <span class="c"># Gradient of 0.5*v*&lt;x&gt;*&lt;x&gt;</span>
            <span class="n">v_QXrrX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kij,...ik-&gt;...ij&#39;</span><span class="p">,</span> <span class="n">QXr_rX</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="c"># Gradient of 0.5*v*Cov</span>
            <span class="n">Q_tr_R_v_R_Cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...k,...k-&gt;...&#39;</span><span class="p">,</span> <span class="n">Q_RCovR</span><span class="p">,</span> <span class="n">v</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,:]</span>

            <span class="c"># Gradient of mu*v*x</span>
            <span class="n">mu_v_R_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...kji-&gt;...ij&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">RX_mu</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">v_QXrrX</span> <span class="o">+</span> <span class="n">Q_tr_R_v_R_Cov</span> <span class="o">-</span> <span class="n">mu_v_R_X</span>

        <span class="k">def</span> <span class="nf">sum_plates</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">plates</span><span class="p">):</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="o">.</span><span class="n">broadcasting_multiplier</span><span class="p">(</span><span class="n">plates</span><span class="p">,</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">V</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span>
                                         <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                         <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
            <span class="n">D_logb</span> <span class="o">=</span> <span class="n">psi</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">b</span><span class="p">)</span>
            <span class="n">XX_Dalpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="n">b</span> <span class="o">*</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">XmuXmu</span><span class="p">,</span> <span class="n">plates_alpha</span><span class="p">))</span>
            <span class="n">D_logalpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">D_logb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XX_Dalpha</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">D_logalpha</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">DXX_alpha</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">D_XX_alpha</span> <span class="o">=</span> <span class="n">DXX_alpha</span> <span class="o">+</span> <span class="n">XX_Dalpha</span>
        <span class="n">D_logdetQ</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="n">sumQ</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Q</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Compute dH(X)</span>
        <span class="n">dQ_logHX</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_logdetQ</span><span class="p">,</span>
                                                         <span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                           <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute d&lt;log p(X|alpha)&gt;</span>
        <span class="n">dQ_logpX</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_XX_alpha</span><span class="p">,</span>
                                                     <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span>
                                          <span class="mi">0</span><span class="p">,</span>
                                          <span class="mi">0</span><span class="p">,</span>
                                          <span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_logalpha</span><span class="p">,</span>
                                                      <span class="n">plates_X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                           <span class="o">*</span> <span class="n">broadcasting_multiplier</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">D</span><span class="p">),</span>
                                                              <span class="n">plates_alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])),</span>
                                          <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>

            <span class="n">D_alpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="n">b</span><span class="p">)</span>
            <span class="n">D_b0_alpha</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">D_alpha</span>
            <span class="n">D_a0_logalpha</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">D_logalpha</span>

            <span class="c"># Compute dH(alpha)</span>
            <span class="c"># This cancels out with the log(alpha) term in log(p(alpha))</span>
            <span class="n">dQ_logHalpha</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># Compute d&lt;log p(alpha)&gt;</span>
            <span class="n">dQ_logpalpha</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gamma_logpdf</span><span class="p">(</span><span class="n">sum_plates</span><span class="p">(</span><span class="n">D_b0_alpha</span><span class="p">,</span>
                                                          <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span>
                                               <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">sum_plates</span><span class="p">(</span><span class="n">D_a0_logalpha</span><span class="p">,</span>
                                                          <span class="n">plates_alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span>
                                               <span class="mi">0</span><span class="p">,</span>
                                               <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">dQ_logHalpha</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">dQ_logpalpha</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
            <span class="n">dQ_bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node_X</span><span class="p">:</span> <span class="n">dQ_logpX</span> <span class="o">+</span> <span class="n">dQ_logHX</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_alpha</span><span class="p">:</span>
                <span class="n">dQ_bound</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">node_alpha</span><span class="p">:</span> <span class="n">dQ_logpalpha</span> <span class="o">+</span> <span class="n">dQ_logHalpha</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dQ_bound</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">dQ_logpX</span>
            <span class="o">+</span> <span class="n">dQ_logpX</span>
            <span class="o">+</span> <span class="n">dQ_logpalpha</span>
            <span class="o">+</span> <span class="n">dQ_logHX</span>
            <span class="o">+</span> <span class="n">dQ_logHalpha</span>
                        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">dR_bound</span><span class="p">,</span> <span class="n">dQ_bound</span><span class="p">)</span>



<div class="viewcode-block" id="RotateGaussianARD.bound"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.bound.html#bayespy.inference.vmp.transformations.RotateGaussianARD.bound">[docs]</a>    <span class="k">def</span> <span class="nf">bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> 
                                   <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span> 
                                   <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span> 
                                   <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span>
                                   <span class="n">gradient</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="RotateGaussianARD.get_bound_terms"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianARD.get_bound_terms.html#bayespy.inference.vmp.transformations.RotateGaussianARD.get_bound_terms">[docs]</a>    <span class="k">def</span> <span class="nf">get_bound_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> 
                                   <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span> 
                                   <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span> 
                                   <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span>
                                   <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                   <span class="n">terms</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


    </div></div>
<div class="viewcode-block" id="RotateGaussianMarkovChain"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain">[docs]</a><span class="k">class</span> <span class="nc">RotateGaussianMarkovChain</span><span class="p">():</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Rotation parameter expansion for :class:`bayespy.nodes.GaussianMarkovChain`</span>
<span class="sd">    </span>
<span class="sd">    Assume the following model.</span>

<span class="sd">    Constant, unit isotropic innovation noise. Unit variance only?</span>

<span class="sd">    Maybe: Assume innovation noise with unit variance? Would it help make this</span>
<span class="sd">    function more general with respect to A.</span>

<span class="sd">    TODO: Allow constant A or not rotating A.</span>

<span class="sd">    :math:`A` may vary in time.</span>
<span class="sd">    </span>
<span class="sd">    Shape of A: (N,D,D)</span>
<span class="sd">    Shape of AA: (N,D,D,D)</span>

<span class="sd">    No plates for X.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RotateGaussianMarkovChain.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.__init__.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_node</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_rotator</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong number of arguments&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="RotateGaussianMarkovChain.nodes"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.nodes.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_rotator</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RotateGaussianMarkovChain.rotate"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.rotate.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logdet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_rotator</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=-</span><span class="n">logdet</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_computations_for_A_and_X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XpXn</span><span class="p">,</span> <span class="n">XpXp</span><span class="p">):</span>
        <span class="c"># Get moments of the state dynamics matrix</span>
        <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">AA</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_node</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>
        <span class="c"># Ignore axes that correspond to input signals</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="n">D</span><span class="p">]</span>
        <span class="n">AA</span> <span class="o">=</span> <span class="n">AA</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="n">D</span><span class="p">,:</span><span class="n">D</span><span class="p">]</span>
        <span class="c"># Make sure time axis is in the arrays</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">AA</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">CovA</span> <span class="o">=</span> <span class="n">AA</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>

        <span class="c">#</span>
        <span class="c"># Expectations with respect to A and X</span>
        <span class="c">#</span>

        <span class="c"># TODO: In case A does not depend on time, use a bit more efficient</span>
        <span class="c"># formulas</span>

        <span class="c"># Compute: \sum_n &lt;A_n&gt; &lt;x_{n-1} x_n^T&gt;</span>
        <span class="n">A_XpXn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...nik,...nkj-&gt;...ij&#39;</span><span class="p">,</span>
                           <span class="n">A</span><span class="p">,</span>
                           <span class="n">XpXn</span><span class="p">)</span>
        <span class="n">A_XpXn</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">A_XpXn</span><span class="p">,</span>
                               <span class="p">(),</span>
                               <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                               <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>

        <span class="c"># Compute: \sum_n &lt;A_n&gt; &lt;x_{n-1} x_{n-1}^T&gt; &lt;A_n&gt;^T</span>
        <span class="n">A_XpXp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...nik,...nkj-&gt;...nij&#39;</span><span class="p">,</span> 
                           <span class="n">A</span><span class="p">,</span>
                           <span class="n">XpXp</span><span class="p">)</span>
        <span class="n">A_XpXp_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...nik,...njk-&gt;...ij&#39;</span><span class="p">,</span> 
                             <span class="n">A_XpXp</span><span class="p">,</span>
                             <span class="n">A</span><span class="p">)</span>
        <span class="n">A_XpXp_A</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">A_XpXp_A</span><span class="p">,</span>
                                 <span class="p">(),</span>
                                 <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                 <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>

        <span class="c"># Compute: \sum_n tr(CovA_n &lt;x_{n-1} x_{n-1}^T&gt;)</span>
        <span class="n">CovA_XpXp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ndij,...nij-&gt;...d&#39;</span><span class="p">,</span>
                              <span class="n">CovA</span><span class="p">,</span>
                              <span class="n">XpXp</span><span class="p">)</span>
        <span class="n">CovA_XpXp</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">CovA_XpXp</span><span class="p">,</span>
                                  <span class="p">(),</span>
                                  <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                  <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">A_XpXn</span><span class="p">,</span> <span class="n">A_XpXp_A</span><span class="p">,</span> <span class="n">CovA_XpXp</span><span class="p">)</span>

<div class="viewcode-block" id="RotateGaussianMarkovChain.setup"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.setup.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should be called just before optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Get moments of X</span>
        <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">XnXn</span><span class="p">,</span> <span class="n">XpXn</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>

        <span class="c"># TODO/FIXME: Sum to plates of A/CovA</span>
        <span class="n">XpXp</span> <span class="o">=</span> <span class="n">XnXn</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span>

        <span class="c">#</span>
        <span class="c"># Expectations with respect to X</span>
        <span class="c">#</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">X0</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X0X0</span> <span class="o">=</span> <span class="n">XnXn</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span>
        <span class="c">#self.XnXn = np.sum(XnXn[...,1:,:,:], axis=-3)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">XnXn</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">XnXn</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,:,:],</span>
                                  <span class="p">(),</span>
                                  <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span>
                                  <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c"># Get moments of the fixed parameter nodes</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda_mu_X0</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...ik,...k-&gt;...i&#39;</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">,</span>
                                                   <span class="n">mu</span><span class="p">),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">X0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lambda_mu_X0</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda_mu_X0</span><span class="p">,</span>
                                          <span class="p">(),</span>
                                          <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">,</span>
                                          <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># Prepare the rotation for A</span>
        <span class="c">#</span>

        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_XpXn</span><span class="p">,</span> 
         <span class="bp">self</span><span class="o">.</span><span class="n">A_XpXp_A</span><span class="p">,</span> 
         <span class="bp">self</span><span class="o">.</span><span class="n">CovA_XpXp</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_computations_for_A_and_X</span><span class="p">(</span><span class="n">XpXn</span><span class="p">,</span> <span class="n">XpXp</span><span class="p">)</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">A_rotator</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">plate_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Innovation noise is assumed to be I</span>
        <span class="c">#self.v = self.X_node.parents[3].get_moments()[0]</span>
</div>
    <span class="k">def</span> <span class="nf">_compute_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate q(X) as X-&gt;RX: q(X)=N(R*mu, R*Cov*R&#39;)</span>

<span class="sd">        Assume:</span>
<span class="sd">        :math:`p(\mathbf{X}) = \prod^M_{m=1} </span>
<span class="sd">               N(\mathbf{x}_m|0, \mathbf{\Lambda})`</span>

<span class="sd">        Assume unit innovation noise covariance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO/FIXME: X and alpha should NOT contain observed values!! Check</span>
        <span class="c"># that.</span>

        <span class="c"># Assume constant mean and precision matrix over plates..</span>

        <span class="k">if</span> <span class="n">inv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">invR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invR</span> <span class="o">=</span> <span class="n">inv</span>

        <span class="k">if</span> <span class="n">logdet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logdetR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logdetR</span> <span class="o">=</span> <span class="n">logdet</span>

        <span class="c"># Transform moments of X and A:</span>
        
        <span class="n">Lambda_R_X0X0</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X0X0</span><span class="p">),</span>
                                      <span class="p">(),</span>
                                      <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">,</span>
                                      <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">R_XnXn</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">XnXn</span><span class="p">)</span>
        <span class="n">RA_XpXp_A</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_XpXp_A</span><span class="p">)</span>
        <span class="n">sumr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">R_CovA_XpXp</span> <span class="o">=</span> <span class="n">sumr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CovA_XpXp</span>

        <span class="c"># Compute entropy H(X)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="c"># total number of rotated vectors</span>
        <span class="n">logH_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">logdetR</span><span class="p">,</span> 
                                         <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute &lt;log p(X)&gt;</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">tracedot</span><span class="p">(</span><span class="n">R_XnXn</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">tracedot</span><span class="p">(</span><span class="n">Lambda_R_X0X0</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">yz</span> <span class="o">=</span> <span class="n">tracedot</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">A_XpXn</span><span class="p">),</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">tracedot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lambda_mu_X0</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">tracedot</span><span class="p">(</span><span class="n">RA_XpXp_A</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...k,...k-&gt;...&#39;</span><span class="p">,</span>
                                                  <span class="n">R_CovA_XpXp</span><span class="p">,</span>
                                                  <span class="n">sumr</span><span class="p">)</span>
        <span class="n">logp_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span>
                                        <span class="n">yz</span><span class="p">,</span>
                                        <span class="n">zz</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute the bound</span>
        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="p">:</span> <span class="n">logp_X</span> <span class="o">+</span> <span class="n">logH_X</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">logp_X</span> <span class="o">+</span> <span class="n">logH_X</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gradient</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bound</span>
        
        <span class="c"># Compute dH(X)</span>
        <span class="n">dlogH_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_entropy</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">invR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                          <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Compute d&lt;log p(X)&gt;</span>
        <span class="n">dyy</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">R_XnXn</span> <span class="o">+</span> <span class="n">Lambda_R_X0X0</span><span class="p">)</span>
        <span class="n">dyz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_XpXn</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_XpXn</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lambda_mu_X0</span>
        <span class="n">dzz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">RA_XpXp_A</span> <span class="o">+</span> <span class="n">R_CovA_XpXp</span><span class="p">[</span><span class="bp">None</span><span class="p">,:])</span>
        <span class="n">dlogp_X</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">gaussian_logpdf</span><span class="p">(</span><span class="n">dyy</span><span class="p">,</span>
                                         <span class="n">dyz</span><span class="p">,</span>
                                         <span class="n">dzz</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">,</span>
                                         <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">d_bound</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="p">:</span> <span class="n">dlogp_X</span> <span class="o">+</span> <span class="n">dlogH_X</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_bound</span> <span class="o">=</span> <span class="p">(</span>
                       <span class="o">+</span> <span class="n">dlogp_X</span>
                       <span class="o">+</span> <span class="n">dlogH_X</span>
                       <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">d_bound</span><span class="p">)</span>

    
<div class="viewcode-block" id="RotateGaussianMarkovChain.bound"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.bound.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.bound">[docs]</a>    <span class="k">def</span> <span class="nf">bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">inv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logdet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="p">(</span><span class="n">bound_X</span><span class="p">,</span> <span class="n">d_bound_X</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span>
                                                   <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span>
                                                   <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span>
                                                   <span class="n">gradient</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c"># Compute cost and gradient from A</span>
        <span class="p">(</span><span class="n">bound_A</span><span class="p">,</span> <span class="n">dR_bound_A</span><span class="p">,</span> <span class="n">dQ_bound_A</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_rotator</span><span class="o">.</span><span class="n">bound</span><span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                                                                 <span class="n">inv</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                 <span class="n">logdet</span><span class="o">=-</span><span class="n">logdet</span><span class="p">,</span>
                                                                 <span class="n">Q</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
        <span class="n">dR_bound_A</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dR_bound_A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">inv</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c"># Compute the bound</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="n">bound_X</span> <span class="o">+</span> <span class="n">bound_A</span>
        <span class="n">d_bound</span> <span class="o">=</span> <span class="n">d_bound_X</span> <span class="o">+</span> <span class="n">dR_bound_A</span> <span class="o">+</span> <span class="n">dQ_bound_A</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">d_bound</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RotateGaussianMarkovChain.get_bound_terms"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.get_bound_terms.html#bayespy.inference.vmp.transformations.RotateGaussianMarkovChain.get_bound_terms">[docs]</a>    <span class="k">def</span> <span class="nf">get_bound_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">inv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logdet</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">R</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="n">terms_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_rotator</span><span class="o">.</span><span class="n">get_bound_terms</span><span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                                                 <span class="n">inv</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                 <span class="n">logdet</span><span class="o">=-</span><span class="n">logdet</span><span class="p">,</span>
                                                 <span class="n">Q</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
        
        <span class="n">terms_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span>
                                      <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span>
                                      <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span>
                                      <span class="n">gradient</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="n">terms</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">terms_X</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">terms_A</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">terms_X</span>

    </div></div>
<div class="viewcode-block" id="RotateVaryingMarkovChain"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotateVaryingMarkovChain.html#bayespy.inference.vmp.transformations.RotateVaryingMarkovChain">[docs]</a><span class="k">class</span> <span class="nc">RotateVaryingMarkovChain</span><span class="p">(</span><span class="n">RotateGaussianMarkovChain</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Rotation for :class:`bayespy.nodes.SwitchingGaussianMarkovChain`</span>
<span class="sd">    </span>
<span class="sd">    Assume the following model.</span>

<span class="sd">    Constant, unit isotropic innovation noise.</span>

<span class="sd">    :math:`A_n = \sum_k B_k s_{kn}`</span>
<span class="sd">    </span>
<span class="sd">    Gaussian B: (1,D) x (D,K)</span>
<span class="sd">    Gaussian S: (N,1) x (K)</span>
<span class="sd">    MC X:          () x (N+1,D)</span>

<span class="sd">    No plates for X.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RotateVaryingMarkovChain.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateVaryingMarkovChain.__init__.html#bayespy.inference.vmp.transformations.RotateVaryingMarkovChain.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B_rotator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_node</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_node</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_rotator</span> <span class="o">=</span> <span class="n">B_rotator</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">S</span><span class="o">.</span><span class="n">plates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The length of the last plate of S must be 1.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">B</span><span class="o">.</span><span class="n">plates</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The length of the last plate of B must be 1.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;S should have exactly one variable axis&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;B should have exactly two variable axes&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">B_rotator</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_computations_for_A_and_X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XpXn</span><span class="p">,</span> <span class="n">XpXp</span><span class="p">):</span>

        <span class="c"># Get moments of B and S</span>
        <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">BB</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_node</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>
        <span class="n">CovB</span> <span class="o">=</span> <span class="n">BB</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,:,:]</span>
        
        <span class="n">u_S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_node</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">u_S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">SS</span> <span class="o">=</span> <span class="n">u_S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c">#</span>
        <span class="c"># Expectations with respect to A and X</span>
        <span class="c">#</span>

        <span class="c"># TODO/FIXME: If S and B have overlapping plates, then these will give</span>
        <span class="c"># wrong results, because those plates of S are summed before multiplying</span>
        <span class="c"># by the plates of B. There should be some &quot;smart einsum&quot; function which</span>
        <span class="c"># would compute sum-multiplys intelligently given a number of inputs.</span>
        
        <span class="c"># Compute: \sum_n &lt;A_n&gt; &lt;x_{n-1} x_n^T&gt;</span>
        <span class="c"># Axes: (N, D, D, D, K)</span>
        <span class="n">S_XpXn</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,:],</span>
                                   <span class="n">XpXn</span><span class="p">[</span><span class="o">...</span><span class="p">,:,</span><span class="bp">None</span><span class="p">,:,:,</span><span class="bp">None</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                   <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">A_XpXn</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,</span><span class="bp">None</span><span class="p">,:],</span>
                                   <span class="n">S_XpXn</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,:],</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                   <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># Compute: \sum_n &lt;A_n&gt; &lt;x_{n-1} x_{n-1}^T&gt; &lt;A_n&gt;^T</span>
        <span class="c"># Axes: (N, D, D, D, K, D, K)</span>
        <span class="n">SS_XpXp</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">SS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,:,</span><span class="bp">None</span><span class="p">,:],</span>
                                    <span class="n">XpXp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,:,</span><span class="bp">None</span><span class="p">,:,</span><span class="bp">None</span><span class="p">],</span>
                                    <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">B_SS_XpXp</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,:,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">],</span>
                                      <span class="n">SS_XpXp</span><span class="p">[</span><span class="o">...</span><span class="p">,:,:,:,:],</span>
                                      <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span>
                                      <span class="n">sumaxis</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">A_XpXp_A</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">B_SS_XpXp</span><span class="p">[</span><span class="o">...</span><span class="p">,:,</span><span class="bp">None</span><span class="p">,:,:],</span>
                                     <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,:,:,:],</span>
                                     <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span>
                                     <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># Compute: \sum_n tr(CovA_n &lt;x_{n-1} x_{n-1}^T&gt;)</span>
        <span class="c"># Axes: (D,D,K,D,K)</span>
        <span class="n">CovA_XpXp</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">sum_multiply</span><span class="p">(</span><span class="n">CovB</span><span class="p">,</span>
                                      <span class="n">SS_XpXp</span><span class="p">,</span>
                                      <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,),</span>
                                      <span class="n">sumaxis</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">A_XpXn</span><span class="p">,</span> <span class="n">A_XpXp_A</span><span class="p">,</span> <span class="n">CovA_XpXp</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="RotateSwitchingMarkovChain"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotateSwitchingMarkovChain.html#bayespy.inference.vmp.transformations.RotateSwitchingMarkovChain">[docs]</a><span class="k">class</span> <span class="nc">RotateSwitchingMarkovChain</span><span class="p">(</span><span class="n">RotateGaussianMarkovChain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotation for :class:`bayespy.nodes.VaryingGaussianMarkovChain`</span>

<span class="sd">    Assume the following model.</span>

<span class="sd">    Constant, unit isotropic innovation noise.</span>

<span class="sd">    :math:`A_n = B_{z_n}`</span>
<span class="sd">    </span>
<span class="sd">    Gaussian B:            (..., K,  D) x   (D)</span>
<span class="sd">    Categorical Z:         (...,   N-1) x   (K)</span>
<span class="sd">    GaussianMarkovChain X: (...)        x (N,D)</span>

<span class="sd">    No plates for X.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RotateSwitchingMarkovChain.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateSwitchingMarkovChain.__init__.html#bayespy.inference.vmp.transformations.RotateSwitchingMarkovChain.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">B_rotator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_node</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Z_node</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">CategoricalMoments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_rotator</span> <span class="o">=</span> <span class="n">B_rotator</span>

        <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_node</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_node</span><span class="o">.</span><span class="n">plates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Incorrect plate length in Z&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_node</span><span class="o">.</span><span class="n">plates</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">D</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Incorrect plates in B&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_node</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Z should have exactly one variable axis&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B_node</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;B should have exactly one variable axes&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">B_rotator</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_computations_for_A_and_X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XpXn</span><span class="p">,</span> <span class="n">XpXp</span><span class="p">):</span>

        <span class="c"># Get moments of B and Z</span>
        <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">BB</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_node</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>
        <span class="n">CovB</span> <span class="o">=</span> <span class="n">BB</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,:,</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="bp">None</span><span class="p">,:]</span>
        
        <span class="n">u_Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_node</span><span class="o">.</span><span class="n">get_moments</span><span class="p">()</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">u_Z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c">#</span>
        <span class="c"># Expectations with respect to A and X</span>
        <span class="c">#</span>

        <span class="c"># Compute: \sum_n &lt;A_n&gt; &lt;x_{n-1} x_n^T&gt;</span>
        <span class="n">Z_XpXn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...nij,...nk-&gt;...kij&#39;</span><span class="p">,</span>
                           <span class="n">XpXn</span><span class="p">,</span>
                           <span class="n">Z</span><span class="p">)</span>
        <span class="n">A_XpXn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kil,...klj-&gt;...ij&#39;</span><span class="p">,</span>
                           <span class="n">B</span><span class="p">,</span>
                           <span class="n">Z_XpXn</span><span class="p">)</span>
        <span class="n">A_XpXn</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">A_XpXn</span><span class="p">,</span>
                               <span class="p">(),</span>
                               <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                               <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>
        
        <span class="c"># Compute: \sum_n &lt;A_n&gt; &lt;x_{n-1} x_{n-1}^T&gt; &lt;A_n&gt;^T</span>
        <span class="n">Z_XpXp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...nij,...nk-&gt;...kij&#39;</span><span class="p">,</span>
                           <span class="n">XpXp</span><span class="p">,</span>
                           <span class="n">Z</span><span class="p">)</span>
        <span class="n">B_Z_XpXp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kil,...klj-&gt;...kij&#39;</span><span class="p">,</span>
                             <span class="n">B</span><span class="p">,</span>
                             <span class="n">Z_XpXp</span><span class="p">)</span>
        <span class="n">A_XpXp_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kil,...kjl-&gt;...ij&#39;</span><span class="p">,</span>
                             <span class="n">B_Z_XpXp</span><span class="p">,</span>
                             <span class="n">B</span><span class="p">)</span>
        <span class="n">A_XpXp_A</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">A_XpXp_A</span><span class="p">,</span>
                                 <span class="p">(),</span>
                                 <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                 <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>
        
        <span class="c"># Compute: \sum_n tr(CovA_n &lt;x_{n-1} x_{n-1}^T&gt;)</span>
        <span class="n">CovA_XpXp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;...kij,...kdij-&gt;...d&#39;</span><span class="p">,</span>
                              <span class="n">Z_XpXp</span><span class="p">,</span>
                              <span class="n">CovB</span><span class="p">)</span>
        <span class="n">CovA_XpXp</span> <span class="o">=</span> <span class="n">sum_to_plates</span><span class="p">(</span><span class="n">CovA_XpXp</span><span class="p">,</span>
                                  <span class="p">(),</span>
                                  <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                  <span class="n">plates_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_node</span><span class="o">.</span><span class="n">plates</span><span class="p">)</span>


        <span class="k">return</span> <span class="p">(</span><span class="n">A_XpXn</span><span class="p">,</span> <span class="n">A_XpXp_A</span><span class="p">,</span> <span class="n">CovA_XpXp</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="RotateMultiple"><a class="viewcode-back" href="../../../../user_api/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.html#bayespy.inference.vmp.transformations.RotateMultiple">[docs]</a><span class="k">class</span> <span class="nc">RotateMultiple</span><span class="p">():</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Identical parameter expansion for several nodes simultaneously</span>
<span class="sd">    </span>
<span class="sd">    Performs the same rotation for multiple nodes and combines the cost</span>
<span class="sd">    effect.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RotateMultiple.__init__"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.__init__.html#bayespy.inference.vmp.transformations.RotateMultiple.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">rotators</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotators</span> <span class="o">=</span> <span class="n">rotators</span>
</div>
<div class="viewcode-block" id="RotateMultiple.nodes"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.nodes.html#bayespy.inference.vmp.transformations.RotateMultiple.nodes">[docs]</a>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">node</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">rotator</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">rotator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotators</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="RotateMultiple.rotate"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.rotate.html#bayespy.inference.vmp.transformations.RotateMultiple.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">rotator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotators</span><span class="p">:</span>
            <span class="n">rotator</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RotateMultiple.setup"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.setup.html#bayespy.inference.vmp.transformations.RotateMultiple.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">rotator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotators</span><span class="p">:</span>
            <span class="n">rotator</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="RotateMultiple.bound"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.bound.html#bayespy.inference.vmp.transformations.RotateMultiple.bound">[docs]</a>    <span class="k">def</span> <span class="nf">bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dbound</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">rotator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotators</span><span class="p">:</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="n">rotator</span><span class="o">.</span><span class="n">bound</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="n">logdet</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="n">inv</span><span class="p">)</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span> <span class="o">+</span> <span class="n">b</span>
            <span class="n">dbound</span> <span class="o">=</span> <span class="n">dbound</span> <span class="o">+</span> <span class="n">db</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">dbound</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RotateMultiple.get_bound_terms"><a class="viewcode-back" href="../../../../user_api/generated/generated/generated/bayespy.inference.vmp.transformations.RotateMultiple.get_bound_terms.html#bayespy.inference.vmp.transformations.RotateMultiple.get_bound_terms">[docs]</a>    <span class="k">def</span> <span class="nf">get_bound_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">logdet</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">terms</span> 
                <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span> <span class="ow">in</span> <span class="n">rotator</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">rotator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotators</span><span class="p">}</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">BayesPy v0.3.5 Documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../inference.html" >bayespy.inference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2015, Jaakko Luttinen, MIT.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>